<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Projection Mapping Tool</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Custom Styles -->
    <style>
      /* Reset & Base */
      html, body {
        background-color: #000;
        color: #fff;
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        overscroll-behavior: none;
        touch-action: none;
      }

      .no-scrollbar::-webkit-scrollbar { display: none; }
      .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

      /* GPU Acceleration Class */
      .gpu-accelerated {
          will-change: transform;
          transform: translateZ(0);
          backface-visibility: hidden;
          transform-style: preserve-3d;
      }

      /* --- ANIMATIONS --- */
      
      /* Existing Animations */
      .animate-glow { animation: neon-pulse 2s infinite linear; }
      .animate-dash { animation: dash-cycle 2s infinite linear; }
      .animate-draw { 
          animation-name: draw-stroke;
          animation-iteration-count: 1;
          animation-fill-mode: forwards;
          animation-timing-function: linear; 
      }
      .animate-hue { animation: hue-cycle 5s infinite linear; }
      .animate-spin-3d { 
          animation: spin-3d 5s infinite linear; 
          transform-style: preserve-3d;
      }
      .animate-text-3d {
          animation: text-3d-complex 6s infinite ease-in-out;
          transform-style: preserve-3d;
          display: inline-block;
      }
      .animate-text-pulse {
          animation: text-pulse-glow 2s infinite ease-in-out;
          display: inline-block;
      }
      .animate-text-flip {
          animation: text-flip-3d 4s infinite linear;
          transform-style: preserve-3d;
          display: inline-block;
      }
      .animate-image-chase {
          mask-image: repeating-linear-gradient(90deg, black 0%, black 25%, transparent 25%, transparent 50%);
          -webkit-mask-image: repeating-linear-gradient(90deg, black 0%, black 25%, transparent 25%, transparent 50%);
          mask-size: 200% 100%;
          -webkit-mask-size: 200% 100%;
          animation: mask-scroll 2s infinite linear;
      }
      .animate-image-draw {
          animation: reveal-wipe 2s forwards linear; 
      }
      .animate-scanner { 
          background-size: 200% 100% !important; 
          animation: scanner-swipe 2s infinite linear; 
      }

      /* --- NEW ANIMATIONS --- */
      .animate-shake { animation: shake 0.5s infinite ease-in-out; }
      .animate-float { animation: float 3s infinite ease-in-out; }
      .animate-blink { animation: blink 1s infinite steps(1); }
      .animate-sway { animation: sway 4s infinite ease-in-out; transform-origin: top center; }
      .animate-scale { animation: scale-pulse 2s infinite ease-in-out; }
      .animate-glitch { animation: glitch 0.3s infinite linear; }

      /* --- KEYFRAMES --- */
      @keyframes neon-pulse {
        0% { filter: drop-shadow(0 0 2px) hue-rotate(0deg); opacity: 0.8; }
        50% { filter: drop-shadow(0 0 10px) hue-rotate(180deg); opacity: 1; }
        100% { filter: drop-shadow(0 0 2px) hue-rotate(360deg); opacity: 0.8; }
      }
      @keyframes hue-cycle {
        0% { filter: hue-rotate(0deg); }
        100% { filter: hue-rotate(360deg); }
      }
      @keyframes dash-cycle { to { stroke-dashoffset: -1000; } }
      @keyframes draw-stroke { to { stroke-dashoffset: 0; } }
      @keyframes scanner-swipe {
        0% { background-position: 100% 0; }
        100% { background-position: -100% 0; }
      }
      @keyframes spin-3d {
        0% { transform: rotateY(0deg) rotateX(10deg); }
        100% { transform: rotateY(360deg) rotateX(10deg); }
      }
      @keyframes text-3d-complex {
          0% { transform: translate3d(0, 0, 0) rotate3d(1, 1, 1, 0deg) scale3d(1, 1, 1); }
          25% { transform: translate3d(20px, -10px, 50px) rotate3d(0, 1, 0.5, 45deg) scale3d(1.1, 1.1, 1.1); }
          50% { transform: translate3d(0, 20px, 100px) rotate3d(1, 0.2, 0, 180deg) scale3d(0.9, 0.9, 0.9); }
          75% { transform: translate3d(-20px, -10px, 50px) rotate3d(0, -1, 0.5, 270deg) scale3d(1.2, 1.2, 1.2); }
          100% { transform: translate3d(0, 0, 0) rotate3d(1, 1, 1, 360deg) scale3d(1, 1, 1); }
      }
      @keyframes text-pulse-glow {
          0%, 100% { transform: scale(1); filter: drop-shadow(0 0 5px currentColor); opacity: 0.8; }
          50% { transform: scale(1.1); filter: drop-shadow(0 0 20px currentColor); opacity: 1; }
      }
      @keyframes text-flip-3d {
          0% { transform: rotateY(0deg); }
          100% { transform: rotateY(360deg); }
      }
      @keyframes reveal-wipe {
        0% { clip-path: inset(0 100% 0 0); }
        100% { clip-path: inset(0 0 0 0); }
      }
      @keyframes mask-scroll {
        0% { mask-position: 100% 0; -webkit-mask-position: 100% 0; }
        100% { mask-position: -100% 0; -webkit-mask-position: -100% 0; }
      }

      /* --- NEW KEYFRAMES --- */
      @keyframes shake {
        0%, 100% { transform: translate(0, 0); }
        25% { transform: translate(-5px, 5px); }
        50% { transform: translate(5px, -5px); }
        75% { transform: translate(-5px, -5px); }
      }
      @keyframes float {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-30px); }
      }
      @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0; }
      }
      @keyframes sway {
        0%, 100% { transform: rotate(-8deg); }
        50% { transform: rotate(8deg); }
      }
      @keyframes scale-pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.15); }
      }
      @keyframes glitch {
        0% { clip-path: inset(20% 0 30% 0); transform: translate(-5px, 5px); }
        20% { clip-path: inset(60% 0 10% 0); transform: translate(5px, -5px); }
        40% { clip-path: inset(40% 0 50% 0); transform: translate(-5px, 0px); }
        60% { clip-path: inset(80% 0 5% 0); transform: translate(5px, 5px); }
        80% { clip-path: inset(10% 0 70% 0); transform: translate(-5px, -5px); }
        100% { clip-path: inset(0 0 0 0); transform: translate(0); }
      }
    </style>

    <!-- React & Babel Standalone -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/"
  }
}
</script>
</head>
<body>
    <div id="root"></div>

    <!-- MAIN APPLICATION SCRIPT -->
    <script type="text/babel" data-presets="typescript,react">
        const { useState, useRef, useEffect, useCallback, useMemo } = React;
        
        // --- HELPERS ---
        function uuidv4() {
          return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
          });
        }

        const SurfaceType = {
          IMAGE: 'IMAGE',
          VIDEO: 'VIDEO',
          COLOR: 'COLOR',
          LINE: 'LINE',
          TEXT: 'TEXT',
        };

        // --- UTILS: MATRIX & MATH ---
        function solve(A, b) {
          const n = A.length;
          for (let i = 0; i < n; i++) {
            let maxEl = Math.abs(A[i][i]);
            let maxRow = i;
            for (let k = i + 1; k < n; k++) {
              if (Math.abs(A[k][i]) > maxEl) {
                maxEl = Math.abs(A[k][i]);
                maxRow = k;
              }
            }
            for (let k = i; k < n; k++) {
              const tmp = A[maxRow][k];
              A[maxRow][k] = A[i][k];
              A[i][k] = tmp;
            }
            const tmp = b[maxRow];
            b[maxRow] = b[i];
            b[i] = tmp;
            for (let k = i + 1; k < n; k++) {
              const c = -A[k][i] / A[i][i];
              for (let j = i; j < n; j++) {
                if (i === j) { A[k][j] = 0; } 
                else { A[k][j] += c * A[i][j]; }
              }
              b[k] += c * b[i];
            }
          }
          const x = new Array(n).fill(0);
          for (let i = n - 1; i > -1; i--) {
            let sum = 0;
            for (let j = i + 1; j < n; j++) { sum += A[i][j] * x[j]; }
            x[i] = (b[i] - sum) / A[i][i];
          }
          return x;
        }

        function getPerspectiveTransform(width, height, corners) {
          const [p0, p1, p2, p3] = corners;
          const A = [];
          const b = [];
          const srcPts = [{x: 0, y: 0}, {x: width, y: 0}, {x: width, y: height}, {x: 0, y: height}];

          for(let i=0; i<4; i++) {
            const s = srcPts[i];
            const d = corners[i];
            A.push([s.x, s.y, 1, 0, 0, 0, -s.x*d.x, -s.y*d.x]);
            b.push(d.x);
            A.push([0, 0, 0, s.x, s.y, 1, -s.x*d.y, -s.y*d.y]);
            b.push(d.y);
          }

          const X = solve(A, b);
          const rounded = X.map(val => Math.abs(val) < 0.000001 ? 0 : val);
          
          return `matrix3d(${rounded[0]}, ${rounded[3]}, 0, ${rounded[6]}, ${rounded[1]}, ${rounded[4]}, 0, ${rounded[7]}, 0, 0, 1, 0, ${rounded[2]}, ${rounded[5]}, 0, 1)`;
        }

        function getPolygonPerimeter(points) {
            if (!points || points.length < 2) return 0;
            let len = 0;
            for(let i=0; i<points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i+1)%points.length];
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                len += Math.sqrt(dx*dx + dy*dy);
            }
            return len;
        }

        // --- COMPONENTS ---

        const DrawingModal = ({ onClose, onSave }) => {
            const canvasRef = useRef(null);
            const [isDrawing, setIsDrawing] = useState(false);
            const [ctx, setCtx] = useState(null);
            const [color, setColor] = useState('#00ffff');
            const [lineWidth, setLineWidth] = useState(5);
            const [drawMode, setDrawMode] = useState('free');
            const [startPos, setStartPos] = useState(null);
            const [snapshot, setSnapshot] = useState(null);
            const CANVAS_SIZE = 500; 

            useEffect(() => {
                const canvas = canvasRef.current;
                if (canvas) {
                    canvas.width = CANVAS_SIZE;
                    canvas.height = CANVAS_SIZE;
                    const context = canvas.getContext('2d', { willReadFrequently: true });
                    context.lineCap = 'round';
                    context.lineJoin = 'round';
                    setCtx(context);
                }
            }, []);

            useEffect(() => {
                if(ctx) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = lineWidth;
                }
            }, [ctx, color, lineWidth]);

            const getPos = (e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: (clientX - rect.left) * (canvasRef.current.width / rect.width),
                    y: (clientY - rect.top) * (canvasRef.current.height / rect.height),
                    shiftKey: e.shiftKey
                };
            };

            const startDraw = (e) => {
                if(!ctx) return;
                e.preventDefault();
                setIsDrawing(true);
                const pos = getPos(e);
                setStartPos(pos);
                setSnapshot(ctx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE));
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
            };

            const draw = (e) => {
                if(!isDrawing || !ctx) return;
                e.preventDefault();
                const pos = getPos(e);
                
                if (drawMode !== 'free') {
                    ctx.putImageData(snapshot, 0, 0);
                    ctx.beginPath();
                    const dx = pos.x - startPos.x;
                    const dy = pos.y - startPos.y;
                    
                    if (drawMode === 'line') {
                        ctx.moveTo(startPos.x, startPos.y);
                        ctx.lineTo(pos.x, pos.y);
                    } else if (drawMode === 'circle') {
                        const radius = Math.sqrt(dx*dx + dy*dy);
                        ctx.arc(startPos.x, startPos.y, radius, 0, Math.PI * 2);
                    } else if (drawMode === 'semicircle') {
                        const radius = Math.sqrt(dx*dx + dy*dy) / 2;
                        const centerX = (startPos.x + pos.x) / 2;
                        const centerY = (startPos.y + pos.y) / 2;
                        const angle = Math.atan2(dy, dx);
                        ctx.arc(centerX, centerY, radius, angle, angle + Math.PI);
                    } else if (drawMode === 'arc') {
                        const radius = Math.sqrt(dx*dx + dy*dy);
                        const angle = Math.atan2(dy, dx);
                        ctx.arc(startPos.x, startPos.y, radius, 0, angle);
                    } else if (drawMode === 'curve') {
                        ctx.moveTo(startPos.x, startPos.y);
                        ctx.quadraticCurveTo(startPos.x, pos.y, pos.x, pos.y);
                    }
                    ctx.stroke();
                } else {
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                }
            };

            const stopDraw = () => {
                setIsDrawing(false);
                if(ctx) ctx.closePath();
            };

            return (
                <div className="absolute inset-0 bg-black/90 z-[300] flex items-center justify-center p-4">
                    <div className="bg-zinc-900 border border-zinc-700 rounded-lg p-4 shadow-xl flex flex-col max-w-lg w-full">
                        <div className="flex justify-between items-center mb-4 text-white">
                            <h3 className="text-lg font-bold">Fenster Zeichnen</h3>
                            <div className="flex gap-1">
                                <button onClick={() => setDrawMode('free')} className={`p-2 rounded ${drawMode === 'free' ? 'bg-blue-600' : 'bg-zinc-800'}`} title="Freihand"><i className="fa-solid fa-pen"></i></button>
                                <button onClick={() => setDrawMode('line')} className={`p-2 rounded ${drawMode === 'line' ? 'bg-blue-600' : 'bg-zinc-800'}`} title="Linie"><i className="fa-solid fa-minus"></i></button>
                                <button onClick={() => setDrawMode('circle')} className={`p-2 rounded ${drawMode === 'circle' ? 'bg-blue-600' : 'bg-zinc-800'}`} title="Kreis"><i className="fa-regular fa-circle"></i></button>
                                <button onClick={() => setDrawMode('semicircle')} className={`p-2 rounded ${drawMode === 'semicircle' ? 'bg-blue-600' : 'bg-zinc-800'}`} title="Halbkreis"><i className="fa-solid fa-circle-half-stroke"></i></button>
                                <button onClick={() => setDrawMode('arc')} className={`p-2 rounded ${drawMode === 'arc' ? 'bg-blue-600' : 'bg-zinc-800'}`} title="Bogen"><i className="fa-solid fa-bezier-curve"></i></button>
                                <button onClick={() => setDrawMode('curve')} className={`p-2 rounded ${drawMode === 'curve' ? 'bg-blue-600' : 'bg-zinc-800'}`} title="Kurve"><i className="fa-solid fa-wave-square"></i></button>
                                <button onClick={onClose} className="p-2 text-zinc-400 hover:text-white"><i className="fa-solid fa-xmark"></i></button>
                            </div>
                        </div>
                        
                        <div className="relative w-full aspect-square bg-zinc-950 border border-zinc-800 rounded mb-4 overflow-hidden">
                            <canvas 
                                ref={canvasRef} 
                                className="w-full h-full touch-none cursor-crosshair"
                                onMouseDown={startDraw} onMouseMove={draw} onMouseUp={stopDraw} onMouseLeave={stopDraw}
                                onTouchStart={startDraw} onTouchMove={draw} onTouchEnd={stopDraw}
                            />
                        </div>

                        <div className="flex gap-4 mb-4 items-center">
                            <input type="color" value={color} onChange={(e) => setColor(e.target.value)} className="w-10 h-10 rounded cursor-pointer bg-transparent border-none"/>
                            <div className="flex-1">
                                <label className="text-[10px] text-zinc-500 uppercase">Pinselgröße</label>
                                <input type="range" min="1" max="20" value={lineWidth} onChange={(e) => setLineWidth(parseInt(e.target.value))} className="w-full accent-blue-500 h-2 bg-zinc-800 rounded-lg"/>
                            </div>
                            <button onClick={() => ctx?.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE)} className="w-10 h-10 rounded bg-zinc-800 text-zinc-400 hover:text-white border border-zinc-700"><i className="fa-solid fa-trash"></i></button>
                        </div>

                        <button onClick={() => onSave(canvasRef.current.toDataURL())} className="w-full py-3 bg-gradient-to-r from-cyan-500 to-blue-600 rounded text-white font-bold shadow-lg uppercase">Als Ebene hinzufügen</button>
                    </div>
                </div>
            );
        };
        
        const ScreenDrawingOverlay = ({ onClose, onSave }) => {
            const canvasRef = useRef(null);
            const [isDrawing, setIsDrawing] = useState(false);
            const [ctx, setCtx] = useState(null);
            const [color, setColor] = useState('#00ff00');
            const [lineWidth, setLineWidth] = useState(8);
            const [drawMode, setDrawMode] = useState('free');
            const [startPos, setStartPos] = useState(null);
            const [snapshot, setSnapshot] = useState(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (canvas) {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    const context = canvas.getContext('2d', { willReadFrequently: true });
                    context.lineCap = 'round';
                    context.lineJoin = 'round';
                    setCtx(context);
                }
            }, []);

            useEffect(() => {
                if(ctx) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = lineWidth;
                }
            }, [ctx, color, lineWidth]);

            const getPos = (e) => {
                const x = e.touches ? e.touches[0].clientX : e.clientX;
                const y = e.touches ? e.touches[0].clientY : e.clientY;
                return { x, y };
            };

            const startDraw = (e) => {
                if(!ctx) return;
                setIsDrawing(true);
                const pos = getPos(e);
                setStartPos(pos);
                setSnapshot(ctx.getImageData(0, 0, canvasRef.current.width, canvasRef.current.height));
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
            };

            const draw = (e) => {
                if(!isDrawing || !ctx) return;
                e.preventDefault();
                const pos = getPos(e);
                
                if (drawMode !== 'free') {
                    ctx.putImageData(snapshot, 0, 0);
                    ctx.beginPath();
                    const dx = pos.x - startPos.x;
                    const dy = pos.y - startPos.y;

                    if (drawMode === 'line') {
                        ctx.moveTo(startPos.x, startPos.y);
                        ctx.lineTo(pos.x, pos.y);
                    } else if (drawMode === 'circle') {
                        const radius = Math.sqrt(dx*dx + dy*dy);
                        ctx.arc(startPos.x, startPos.y, radius, 0, Math.PI * 2);
                    } else if (drawMode === 'semicircle') {
                        const radius = Math.sqrt(dx*dx + dy*dy) / 2;
                        const centerX = (startPos.x + pos.x) / 2;
                        const centerY = (startPos.y + pos.y) / 2;
                        const angle = Math.atan2(dy, dx);
                        ctx.arc(centerX, centerY, radius, angle, angle + Math.PI);
                    } else if (drawMode === 'arc') {
                        const radius = Math.sqrt(dx*dx + dy*dy);
                        const angle = Math.atan2(dy, dx);
                        ctx.arc(startPos.x, startPos.y, radius, 0, angle);
                    } else if (drawMode === 'curve') {
                        ctx.moveTo(startPos.x, startPos.y);
                        ctx.quadraticCurveTo(startPos.x, pos.y, pos.x, pos.y);
                    }
                    ctx.stroke();
                } else {
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                }
            };

            const stopDraw = () => {
                setIsDrawing(false);
                if(ctx) ctx.closePath();
            };
            
            const handleSave = () => {
                if (!canvasRef.current) return;
                const w = canvasRef.current.width;
                const h = canvasRef.current.height;
                const ctx2d = canvasRef.current.getContext('2d');
                const imgData = ctx2d.getImageData(0, 0, w, h);
                const { data } = imgData;
                let minX = w, minY = h, maxX = 0, maxY = 0, found = false;

                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] > 0) {
                        const idx = i / 4;
                        const x = idx % w;
                        const y = Math.floor(idx / w);
                        if (x < minX) minX = x; if (x > maxX) maxX = x;
                        if (y < minY) minY = y; if (y > maxY) maxY = y;
                        found = true;
                    }
                }

                if (!found) { onClose(); return; }
                const cropWidth = maxX - minX + 10; const cropHeight = maxY - minY + 10;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = cropWidth; tempCanvas.height = cropHeight;
                const tCtx = tempCanvas.getContext('2d');
                const srcX = Math.max(0, minX - 5); const srcY = Math.max(0, minY - 5);
                tCtx.drawImage(canvasRef.current, srcX, srcY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);
                onSave(tempCanvas.toDataURL('image/png'), { x: srcX, y: srcY, w: cropWidth, h: cropHeight });
            };

            return (
                <div className="fixed inset-0 z-[500] cursor-crosshair">
                     <canvas 
                        ref={canvasRef}
                        className="w-full h-full touch-none"
                        style={{ background: 'rgba(0,0,0,0.3)' }}
                        onMouseDown={startDraw} onMouseMove={draw} onMouseUp={stopDraw} onMouseLeave={stopDraw}
                        onTouchStart={startDraw} onTouchMove={draw} onTouchEnd={stopDraw}
                     />
                     <div className="absolute top-4 left-1/2 transform -translate-x-1/2 flex items-center gap-2 bg-zinc-900/95 p-2 px-4 rounded-full border border-zinc-700 shadow-2xl">
                        <div className="flex gap-1">
                            <button onClick={() => setDrawMode('free')} className={`w-10 h-10 rounded-full flex items-center justify-center transition-colors ${drawMode === 'free' ? 'bg-blue-600 text-white' : 'bg-zinc-800 text-zinc-400'}`} title="Freihand"><i className="fa-solid fa-pen"></i></button>
                            <button onClick={() => setDrawMode('line')} className={`w-10 h-10 rounded-full flex items-center justify-center transition-colors ${drawMode === 'line' ? 'bg-blue-600 text-white' : 'bg-zinc-800 text-zinc-400'}`} title="Linie"><i className="fa-solid fa-minus"></i></button>
                            <button onClick={() => setDrawMode('circle')} className={`w-10 h-10 rounded-full flex items-center justify-center transition-colors ${drawMode === 'circle' ? 'bg-blue-600 text-white' : 'bg-zinc-800 text-zinc-400'}`} title="Kreis"><i className="fa-regular fa-circle"></i></button>
                            <button onClick={() => setDrawMode('semicircle')} className={`w-10 h-10 rounded-full flex items-center justify-center transition-colors ${drawMode === 'semicircle' ? 'bg-blue-600 text-white' : 'bg-zinc-800 text-zinc-400'}`} title="Halbkreis"><i className="fa-solid fa-circle-half-stroke"></i></button>
                            <button onClick={() => setDrawMode('arc')} className={`w-10 h-10 rounded-full flex items-center justify-center transition-colors ${drawMode === 'arc' ? 'bg-blue-600 text-white' : 'bg-zinc-800 text-zinc-400'}`} title="Bogen"><i className="fa-solid fa-bezier-curve"></i></button>
                            <button onClick={() => setDrawMode('curve')} className={`w-10 h-10 rounded-full flex items-center justify-center transition-colors ${drawMode === 'curve' ? 'bg-blue-600 text-white' : 'bg-zinc-800 text-zinc-400'}`} title="Kurve"><i className="fa-solid fa-wave-square"></i></button>
                        </div>
                        <div className="w-[1px] h-6 bg-zinc-800 mx-1"></div>
                        <input type="color" value={color} onChange={(e) => setColor(e.target.value)} className="w-8 h-8 rounded-full border-none cursor-pointer bg-transparent"/>
                        <input type="range" min="1" max="30" value={lineWidth} onChange={(e) => setLineWidth(parseInt(e.target.value))} className="w-24 accent-blue-500"/>
                        <button onClick={handleSave} className="px-4 py-1.5 bg-green-600 hover:bg-green-500 rounded-full text-white text-[10px] font-bold uppercase transition-all shadow-lg shadow-green-900/20">Fertig</button>
                        <button onClick={onClose} className="px-4 py-1.5 bg-red-600 hover:bg-red-500 rounded-full text-white text-[10px] font-bold uppercase transition-all">Abbruch</button>
                     </div>
                </div>
            );
        };

        const SurfaceLayer = ({ surface, isSelected, onSelect, isPlaying = false, globalTime = 0 }) => {
          const INTERNAL_WIDTH = 1000;
          const INTERNAL_HEIGHT = 1000;
          const videoRef = useRef(null);

          const safeStart = Number(surface.timelineStart) || 0;
          const safeDuration = Number(surface.timelineDuration) || 10;

          const isActive = useMemo(() => {
              if (!isPlaying) return surface.visible;
              const end = safeStart + safeDuration;
              return globalTime >= safeStart && globalTime < end;
          }, [isPlaying, globalTime, surface.visible, safeStart, safeDuration]);

          const transformStyle = useMemo(() => {
            return getPerspectiveTransform(INTERNAL_WIDTH, INTERNAL_HEIGHT, surface.corners);
          }, [surface.corners]);

          const maskClipPath = useMemo(() => {
              if (!surface.maskPoints || surface.maskPoints.length < 3) return undefined;
              const pointsStr = surface.maskPoints.map(p => `${p.x}px ${p.y}px`).join(',');
              return `polygon(${pointsStr})`;
          }, [surface.maskPoints]);

          useEffect(() => {
            if (surface.type === SurfaceType.VIDEO && videoRef.current) {
                const vid = videoRef.current;
                vid.volume = surface.volume ?? 1.0;
                vid.muted = surface.isMuted ?? false;
                const shouldLoop = surface.loopMode !== 'once';
                if(vid.loop !== shouldLoop) vid.loop = shouldLoop;

                if (isPlaying) {
                     if (isActive) {
                         const videoOffset = globalTime - safeStart;
                         if (Number.isFinite(vid.duration) && vid.duration > 0) {
                             const diff = Math.abs(vid.currentTime - (videoOffset % vid.duration));
                             if (diff > 0.5 && !vid.seeking) vid.currentTime = videoOffset % vid.duration; 
                         }
                         if (vid.paused) vid.play().catch(e => {});
                     } else {
                         if (!vid.paused) vid.pause();
                         vid.currentTime = 0;
                     }
                } else {
                    if (isActive) { if (vid.paused) vid.play().catch(() => {}); }
                    else vid.pause();
                }
            }
          }, [isPlaying, isActive, globalTime, safeStart, surface.volume, surface.isMuted, surface.type, surface.loopMode]);

          const isLineAndMasked = (surface.type === SurfaceType.LINE && surface.maskPoints && surface.maskPoints.length >= 2);

          const shapeStyle = useMemo(() => {
            if (surface.maskPoints && surface.maskPoints.length >= 3) return {};
            if (surface.type === SurfaceType.LINE) return {}; 
            switch (surface.shape) {
              case 'circle': return { borderRadius: '50%', overflow: 'hidden' };
              case 'triangle': return { clipPath: 'polygon(50% 0%, 0% 100%, 100% 100%)', overflow: 'hidden' };
              case 'rect': default: return { overflow: 'hidden' };
            }
          }, [surface.shape, surface.type, surface.maskPoints]);

          const renderContent = () => {
              if (surface.type === SurfaceType.LINE && surface.maskPoints && surface.maskPoints.length > 0) return null;
              const isAnimated = surface.animationSpeed && surface.animationSpeed > 0;
              const animType = surface.animationType || 'simple';
              let animClass = '';
              
              if (isAnimated) {
                  // MAPPING ANIMATION TYPES TO CSS CLASSES
                  const mapping = {
                      'shake': 'animate-shake',
                      'float': 'animate-float',
                      'blink': 'animate-blink',
                      'sway': 'animate-sway',
                      'scale': 'animate-scale',
                      'glitch': 'animate-glitch',
                      'chase': surface.type === SurfaceType.LINE ? 'animate-dash' : (surface.type === SurfaceType.COLOR ? 'animate-scanner' : 'animate-image-chase'),
                      'draw': surface.type === SurfaceType.LINE ? 'animate-draw' : 'animate-image-draw',
                      'spin3d': 'animate-spin-3d',
                      'pulse': 'animate-text-pulse',
                      'flip': 'animate-text-flip',
                      'simple': surface.type === SurfaceType.TEXT ? 'animate-text-3d' : (surface.type === SurfaceType.IMAGE ? 'animate-hue' : 'animate-glow')
                  };
                  animClass = mapping[animType] || mapping['simple'];
              }

              const animStyle = isAnimated ? { animationDuration: `${surface.animationSpeed}s` } : {};

              switch(surface.type) {
                  case SurfaceType.VIDEO:
                      return <video ref={videoRef} src={surface.src} className="w-full h-full object-fill block" playsInline webkit-playsinline="true" preload="auto" muted={surface.isMuted} />;
                  case SurfaceType.IMAGE:
                      return (
                        <div className="w-full h-full relative">
                            <img src={surface.src} alt={surface.name} className={`w-full h-full object-fill block ${animClass}`} style={animStyle} draggable={false} />
                        </div>
                      );
                  case SurfaceType.TEXT:
                      return (
                          <div className="w-full h-full flex items-center justify-center pointer-events-none" style={{ perspective: '1000px' }}>
                              <div 
                                className={`${animClass} leading-tight text-center`} 
                                style={{ 
                                    color: surface.src, 
                                    fontSize: `${surface.fontSize || 100}px`,
                                    fontWeight: 'bold',
                                    writingMode: surface.isVertical ? 'vertical-rl' : 'horizontal-tb',
                                    textOrientation: 'upright',
                                    ...animStyle
                                }}
                              >
                                {surface.textContent || 'TEXT'}
                              </div>
                          </div>
                      );
                  case SurfaceType.LINE:
                      const strokeWidth = (surface.lineWidth || 10) * 2; const inset = strokeWidth / 2;
                      const w = INTERNAL_WIDTH - strokeWidth; const h = INTERNAL_HEIGHT - strokeWidth;
                      let dashArray = (isAnimated && animType === 'chase') ? `${w/4} ${w/4}` : undefined;
                      let svgTransform = undefined;
                      if (isAnimated && animType === 'draw') {
                          let perimeter = 4000;
                          if (surface.shape === 'rect') perimeter = 2 * (w + h);
                          if (surface.shape === 'circle') perimeter = Math.PI * w; 
                          if (surface.shape === 'triangle') perimeter = w + 2 * Math.sqrt(Math.pow(w/2, 2) + Math.pow(h, 2)); 
                          dashArray = `${perimeter}`;
                          animStyle.strokeDasharray = perimeter; animStyle.strokeDashoffset = perimeter;
                          if (surface.shape === 'rect') { svgTransform = 'rotate(-90deg)'; animStyle.transformOrigin = 'center'; }
                          if (surface.shape === 'circle') { svgTransform = 'rotate(90deg)'; animStyle.transformOrigin = 'center'; }
                      }
                      return (
                          <svg width="100%" height="100%" viewBox={`0 0 ${INTERNAL_WIDTH} ${INTERNAL_HEIGHT}`} className={`overflow-visible ${animClass}`} style={{ ...animStyle, transform: svgTransform }}>
                              {surface.shape === 'rect' && <rect x={inset} y={inset} width={w} height={h} fill="none" stroke={surface.src} strokeWidth={strokeWidth} strokeDasharray={dashArray} />}
                              {surface.shape === 'circle' && <circle cx={INTERNAL_WIDTH / 2} cy={INTERNAL_HEIGHT / 2} r={w / 2} fill="none" stroke={surface.src} strokeWidth={strokeWidth} strokeDasharray={dashArray} />}
                              {surface.shape === 'triangle' && <polygon points={`${INTERNAL_WIDTH/2},${inset} ${INTERNAL_WIDTH - inset},${INTERNAL_HEIGHT - inset} ${inset},${INTERNAL_HEIGHT - inset}`} fill="none" stroke={surface.src} strokeWidth={strokeWidth} strokeDasharray={dashArray} />}
                          </svg>
                      );
                  case SurfaceType.COLOR:
                      const colorStyle = { backgroundColor: surface.src, ...animStyle };
                      if (isAnimated && animType === 'chase') {
                          colorStyle.backgroundColor = 'transparent'; 
                          colorStyle.backgroundImage = `linear-gradient(110deg, ${surface.src} 20%, #ffffff 50%, ${surface.src} 80%)`;
                      }
                      return <div className={`w-full h-full ${animClass}`} style={colorStyle} />;
                  default: return <div className="w-full h-full" style={{ backgroundColor: surface.src }} />;
              }
          }

          if (!isActive) return null;
          const rotation = surface.rotation || 0;
          const isAnimated = surface.animationSpeed && surface.animationSpeed > 0;
          const animType = surface.animationType || 'simple';
          let maskAnimClass = ''; const maskAnimStyle = isAnimated ? { animationDuration: `${surface.animationSpeed}s` } : {};
          
          if (isLineAndMasked && isAnimated) {
             const perimeter = getPolygonPerimeter(surface.maskPoints);
             if (animType === 'chase') { maskAnimClass = 'animate-dash'; maskAnimStyle.strokeDasharray = `${perimeter/20} ${perimeter/20}`; }
             else if (animType === 'draw') { maskAnimClass = 'animate-draw'; maskAnimStyle.strokeDasharray = `${perimeter}`; maskAnimStyle.strokeDashoffset = `${perimeter}`; }
             else { maskAnimClass = 'animate-glow'; }
          }

          return (
            <div className="absolute top-0 left-0 w-full h-full pointer-events-none select-none" style={{ zIndex: surface.zIndex, clipPath: isLineAndMasked ? 'none' : maskClipPath }}>
              {isLineAndMasked && (
                 <svg className="absolute inset-0 w-full h-full overflow-visible">
                     <polygon points={surface.maskPoints.map(p => `${p.x},${p.y}`).join(' ')} fill="none" stroke={surface.src} strokeWidth={surface.lineWidth || 10} className={maskAnimClass} style={maskAnimStyle} />
                 </svg>
              )}
              <div className="origin-top-left absolute pointer-events-auto transition-opacity gpu-accelerated"
                style={{ width: `${INTERNAL_WIDTH}px`, height: `${INTERNAL_HEIGHT}px`, transform: transformStyle, opacity: isLineAndMasked ? 0 : surface.opacity }}
                onClick={(e) => { if (!isPlaying) { e.stopPropagation(); onSelect(surface.id); } }}>
                <div style={{ width: '100%', height: '100%', transform: `rotate(${rotation}deg)`, transformOrigin: 'center', transformStyle: 'preserve-3d' }}>
                    <div style={{ width: '100%', height: '100%', ...shapeStyle }}>{renderContent()}</div>
                    {isSelected && !isPlaying && (
                    <div className="absolute inset-0 border-4 border-blue-500/50 pointer-events-none mix-blend-screen" style={{
                        borderRadius: (!surface.maskPoints && surface.shape === 'circle') ? '50%' : undefined,
                        clipPath: (!surface.maskPoints && surface.shape === 'triangle') ? 'polygon(50% 0%, 0% 100%, 100% 100%)' : undefined
                    }} />
                    )}
                </div>
              </div>
            </div>
          );
        };

        const Sidebar = ({ surfaces, selectedId, editMode, onSetEditMode, onAddSurface, onSelect, onUpdateSurface, onDeleteSurface, onLoadProject, onToggleFullscreen, onCloseMobile, isPlaying, currentTime, onPlay, onStop, onReset, onOpenWindowDrawing, onOpenScreenDrawing }) => {
          const [uploadShape, setUploadShape] = useState('rect');
          const loadFileInputRef = useRef(null);
          const scrollContainerRef = useRef(null);

          useEffect(() => {
              if (selectedId && scrollContainerRef.current) {
                  setTimeout(() => {
                      if(scrollContainerRef.current) {
                          scrollContainerRef.current.scrollTo({ top: scrollContainerRef.current.scrollHeight, behavior: 'smooth' });
                      }
                  }, 100);
              }
          }, [selectedId]);

          const handleFileUpload = (e) => {
            const file = e.target.files?.[0]; if (!file) return; e.target.value = '';
            const reader = new FileReader(); reader.onload = (event) => {
                const result = event.target?.result; if (!result) return;
                if (file.type.startsWith('video/')) {
                    const video = document.createElement('video'); video.preload = 'metadata';
                    video.onloadedmetadata = () => {
                        const w = video.videoWidth; const h = video.videoHeight;
                        const duration = video.duration || 10; const scale = 400 / Math.max(w, h);
                        let finalW = w * scale; let finalH = h * scale;
                        if (uploadShape === 'circle') { const size = Math.max(finalW, finalH); finalW = size; finalH = size; }
                        onAddSurface(SurfaceType.VIDEO, result, uploadShape, finalW, finalH, duration);
                    };
                    video.src = result;
                } else if (file.type.startsWith('image/')) {
                    const img = new Image(); img.onload = () => {
                        const w = img.width; const h = img.height; const scale = 400 / Math.max(w, h);
                        let finalW = w * scale; let finalH = h * scale;
                        if (uploadShape === 'circle') { const size = Math.max(finalW, finalH); finalW = size; finalH = size; }
                        onAddSurface(SurfaceType.IMAGE, result, uploadShape, finalW, finalH);
                    };
                    img.src = result;
                }
            };
            reader.readAsDataURL(file);
          };

          const handleSaveProject = () => {
              const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(surfaces));
              const downloadAnchorNode = document.createElement('a'); downloadAnchorNode.setAttribute("href", dataStr);
              downloadAnchorNode.setAttribute("download", `lumimap_projekt_${new Date().toISOString().slice(0,10)}.json`);
              document.body.appendChild(downloadAnchorNode); downloadAnchorNode.click(); downloadAnchorNode.remove();
          };

          const handleLoadFileChange = (e) => {
              const file = e.target.files?.[0]; if (!file) return;
              const reader = new FileReader(); reader.onload = (ev) => {
                  try { const loaded = JSON.parse(ev.target?.result); onLoadProject(loaded); } catch (err) { alert("Fehler beim Laden."); }
              };
              reader.readAsText(file); e.target.value = '';
          };

          const selectedSurface = surfaces.find(s => s.id === selectedId);
          const toggleMaskMode = (enabled) => {
              if (!selectedSurface) return;
              if (enabled) {
                  onSetEditMode('mask');
                  if (!selectedSurface.maskPoints || selectedSurface.maskPoints.length === 0) {
                      let newPoints = [...selectedSurface.corners];
                      if (selectedSurface.shape === 'triangle') {
                          const [p0, p1, p2, p3] = selectedSurface.corners;
                          const top = { x: (p0.x + p1.x)/2, y: (p0.y + p1.y)/2 }; newPoints = [top, p2, p3]; 
                      } else if (selectedSurface.shape === 'circle') {
                          newPoints = []; const steps = 16; const [p0, p1, p2, p3] = selectedSurface.corners;
                          for(let i=0; i<steps; i++) {
                              const th = (i/steps)*Math.PI*2 - Math.PI/2;
                              const u = 0.5 + 0.5 * Math.cos(th); const v = 0.5 + 0.5 * Math.sin(th);
                              const x = (1-u)*(1-v)*p0.x + u*(1-v)*p1.x + u*v*p2.x + (1-u)*v*p3.x;
                              const y = (1-u)*(1-v)*p0.y + u*(1-v)*p1.y + u*v*p2.y + (1-u)*v*p3.y;
                              newPoints.push({x,y});
                          }
                      }
                      onUpdateSurface(selectedSurface.id, { maskPoints: newPoints });
                  }
              } else onSetEditMode('perspective'); 
          };
          const resetMask = () => { if (!selectedSurface) return; onUpdateSurface(selectedSurface.id, { maskPoints: [...selectedSurface.corners] }); };
          const clearMask = () => { if (!selectedSurface) return; onUpdateSurface(selectedSurface.id, { maskPoints: undefined }); onSetEditMode('perspective'); };
          const formatTime = (t) => { const m = Math.floor(t / 60); const s = Math.floor(t % 60); const ms = Math.floor((t % 1) * 10); return `${m}:${s.toString().padStart(2, '0')}.${ms}`; };
          
          return (
            <div className="w-full md:w-80 h-full bg-zinc-900 border-r border-zinc-800 flex flex-col shadow-2xl z-50 overflow-hidden relative">
              <div className="p-4 border-b border-zinc-800 flex justify-between items-center bg-zinc-950">
                <h1 className="text-xl font-bold bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">Projection Tool</h1>
                <div className="flex gap-4">
                    <button onClick={onCloseMobile} className="text-zinc-400 hover:text-white" title="Menü"><i className="fa-solid fa-eye-slash"></i></button>
                    <button onClick={onToggleFullscreen} className="text-zinc-400 hover:text-white" title="Vollbild"><i className="fa-solid fa-expand"></i></button>
                    <button onClick={onCloseMobile} className="md:hidden text-zinc-400 hover:text-white"><i className="fa-solid fa-xmark"></i></button>
                </div>
              </div>

              <div ref={scrollContainerRef} className="flex-1 overflow-y-auto no-scrollbar p-4 space-y-4 pb-20">
                    <div className="flex gap-2 mb-4">
                        <button onClick={handleSaveProject} className="flex-1 py-2 bg-zinc-800 border border-zinc-700 rounded text-xs text-zinc-300 flex items-center justify-center gap-2 transition hover:bg-zinc-700"><i className="fa-solid fa-floppy-disk"></i> Speichern</button>
                        <button onClick={() => loadFileInputRef.current?.click()} className="flex-1 py-2 bg-zinc-800 border border-zinc-700 rounded text-xs text-zinc-300 flex items-center justify-center gap-2 transition hover:bg-zinc-700"><i className="fa-solid fa-folder-open"></i> Laden</button>
                        <input type="file" ref={loadFileInputRef} onChange={handleLoadFileChange} accept=".json" className="hidden" />
                    </div>
                    <hr className="border-zinc-800 mb-4" />
                    <div className="flex gap-2 mb-4">
                        <button onClick={onOpenWindowDrawing} className="flex-1 py-3 bg-gradient-to-r from-purple-600 to-blue-600 rounded text-white font-bold flex items-center justify-center shadow-lg hover:brightness-110 transition-all text-xs"><i className="fa-solid fa-pencil mr-1"></i> Fenster Zeichnen</button>
                         <button onClick={onOpenScreenDrawing} className="flex-1 py-3 bg-gradient-to-r from-green-600 to-teal-600 rounded text-white font-bold flex items-center justify-center shadow-lg hover:brightness-110 transition-all text-xs"><i className="fa-solid fa-pen-nib mr-1"></i> Direkt Zeichnen</button>
                    </div>

                    <button onClick={() => onAddSurface(SurfaceType.TEXT, '#ffffff', 'rect', 400, 200)} className="w-full py-2 bg-zinc-800 border border-zinc-700 rounded text-xs text-blue-400 font-bold flex items-center justify-center gap-2 mb-4 hover:bg-zinc-700 transition">
                        <i className="fa-solid fa-font"></i> Text hinzufügen
                    </button>

                    <div className="space-y-2">
                        <label className="text-xs font-semibold text-zinc-500 uppercase">Medien Upload</label>
                        <div className="flex bg-zinc-800 p-1 rounded border border-zinc-700 mb-1">
                             {['rect', 'circle', 'triangle'].map((shape) => (
                                <button key={shape} onClick={() => setUploadShape(shape)} className={`flex-1 py-1 rounded text-xs flex justify-center items-center ${uploadShape === shape ? 'bg-zinc-600 text-white shadow-sm' : 'text-zinc-400'}`}><i className={`fa-regular ${shape === 'rect' ? 'fa-square' : shape === 'circle' ? 'fa-circle' : 'fa-play fa-rotate-270'}`}></i></button>
                            ))}
                        </div>
                        <label className="flex items-center justify-center p-3 border border-zinc-700 rounded bg-zinc-800 hover:bg-zinc-700 cursor-pointer transition"><i className="fa-solid fa-upload mr-2 text-zinc-400"></i><span className="text-xs text-zinc-300 uppercase font-bold">Datei wählen</span><input type="file" className="hidden" accept="image/*,video/*" onChange={handleFileUpload} /></label>
                    </div>
                    <div className="space-y-2">
                        <label className="text-xs font-semibold text-zinc-500 uppercase">Neon Linien</label>
                        <div className="grid grid-cols-3 gap-2">
                            <button onClick={() => onAddSurface(SurfaceType.LINE, '#00ffff', 'rect')} className="p-2 border border-zinc-700 rounded bg-zinc-800 flex flex-col items-center hover:bg-zinc-700 transition"><i className="fa-regular fa-square text-cyan-400 mb-1"></i><span className="text-[10px]">Rechteck</span></button>
                            <button onClick={() => onAddSurface(SurfaceType.LINE, '#00ffff', 'circle')} className="p-2 border border-zinc-700 rounded bg-zinc-800 flex flex-col items-center hover:bg-zinc-700 transition"><i className="fa-regular fa-circle text-cyan-400 mb-1"></i><span className="text-[10px]">Kreis</span></button>
                            <button onClick={() => onAddSurface(SurfaceType.LINE, '#00ffff', 'triangle')} className="p-2 border border-zinc-700 rounded bg-zinc-800 flex flex-col items-center hover:bg-zinc-700 transition"><i className="fa-solid fa-play -rotate-90 text-xs text-cyan-400 mb-1"></i><span className="text-[10px]">Dreieck</span></button>
                        </div>
                    </div>
                    <div className="space-y-2">
                         <label className="text-xs font-semibold text-zinc-500 uppercase">Farben</label>
                         <div className="grid grid-cols-3 gap-2">
                            <button onClick={() => onAddSurface(SurfaceType.COLOR, '#ffffff', 'rect')} className="p-2 border border-zinc-700 rounded bg-zinc-800 flex flex-col items-center hover:bg-zinc-700 transition"><i className="fa-regular fa-square text-zinc-400 mb-1"></i><span className="text-[10px]">Rechteck</span></button>
                            <button onClick={() => onAddSurface(SurfaceType.COLOR, '#ffffff', 'circle')} className="p-2 border border-zinc-700 rounded bg-zinc-800 flex flex-col items-center hover:bg-zinc-700 transition"><i className="fa-regular fa-circle text-zinc-400 mb-1"></i><span className="text-[10px]">Kreis</span></button>
                            <button onClick={() => onAddSurface(SurfaceType.COLOR, '#ffffff', 'triangle')} className="p-2 border border-zinc-700 rounded bg-zinc-800 flex flex-col items-center hover:bg-zinc-700 transition"><i className="fa-solid fa-play -rotate-90 text-xs text-zinc-400 mb-1"></i><span className="text-[10px]">Dreieck</span></button>
                        </div>
                    </div>
                    <div className="space-y-2 mt-4 pt-4 border-t border-zinc-800">
                      <h3 className="text-xs font-semibold text-zinc-500 uppercase tracking-wider mb-2">Ebenen Liste</h3>
                      {surfaces.map(s => (
                        <div key={s.id} className={`flex items-center p-2 rounded border cursor-pointer group ${selectedId === s.id ? 'bg-blue-900/30 border-blue-500/50' : 'bg-zinc-800 border-zinc-700'}`} onClick={() => onSelect(s.id)}>
                          <div className="w-8 h-8 rounded bg-zinc-900 mr-3 border border-zinc-700 flex items-center justify-center text-xs text-zinc-500 overflow-hidden">
                              {s.type === 'VIDEO' ? <i className="fa-solid fa-video"></i> : s.type === 'IMAGE' ? <img src={s.src} className="w-full h-full object-cover"/> : s.type === 'TEXT' ? <i className="fa-solid fa-font"></i> : <div className="w-3 h-3 rounded-full" style={{background: s.src}}></div>}
                          </div>
                          <div className="flex-1 min-w-0"><div className="text-sm font-medium text-zinc-200 truncate">{s.name}</div><div className="text-[10px] text-zinc-500 uppercase">{s.type} {s.maskPoints ? '(Maske)' : ''}</div></div>
                          <button onClick={(e) => { e.stopPropagation(); onUpdateSurface(s.id, { visible: !s.visible }); }} className={`p-1.5 rounded hover:bg-zinc-700 ${s.visible ? 'text-zinc-400' : 'text-zinc-600'}`}><i className={`fa-solid ${s.visible ? 'fa-eye' : 'fa-eye-slash'}`}></i></button>
                          <button onClick={(e) => { e.stopPropagation(); onDeleteSurface(s.id); }} className="p-1.5 rounded hover:bg-red-900/50 text-zinc-600 hover:text-red-400 opacity-0 group-hover:opacity-100"><i className="fa-solid fa-trash"></i></button>
                        </div>
                      ))}
                    </div>
                {selectedSurface && (
                  <div className="border-t border-zinc-800 pt-4 mt-2 mb-10">
                    <h3 className="text-xs font-semibold text-zinc-500 uppercase mb-3">Bearbeiten</h3>
                    <div className="bg-zinc-800/50 rounded p-2 mb-4 border border-zinc-700">
                        <div className="flex items-center mb-1 text-xs text-blue-400 font-bold uppercase"><i className="fa-solid fa-clock mr-2"></i> Timeline</div>
                        <div className="grid grid-cols-2 gap-2">
                            <div><label className="text-[10px] text-zinc-400">Start (sek)</label><input type="number" min="0" step="0.1" value={selectedSurface.timelineStart} onChange={(e) => onUpdateSurface(selectedSurface.id, { timelineStart: e.target.value === '' ? '' : parseFloat(e.target.value) })} className="w-full bg-zinc-900 border border-zinc-700 rounded px-2 py-1 text-xs text-white"/></div>
                            <div><label className="text-[10px] text-zinc-400">Dauer (sek)</label><input type="number" min="0.1" step="0.1" value={selectedSurface.timelineDuration} onChange={(e) => onUpdateSurface(selectedSurface.id, { timelineDuration: e.target.value === '' ? '' : parseFloat(e.target.value) })} className="w-full bg-zinc-900 border border-zinc-700 rounded px-2 py-1 text-xs text-white"/></div>
                        </div>
                    </div>
                    
                    {selectedSurface.type === SurfaceType.TEXT && (
                      <div className="bg-zinc-800/50 rounded p-2 mb-4 border border-zinc-700 space-y-3">
                         <div className="flex items-center mb-1 text-xs text-blue-400 font-bold uppercase"><i className="fa-solid fa-keyboard mr-2"></i> Text-Optionen</div>
                         <textarea 
                            value={selectedSurface.textContent || ''} 
                            onChange={(e) => onUpdateSurface(selectedSurface.id, { textContent: e.target.value })}
                            className="w-full bg-zinc-900 border border-zinc-700 rounded p-2 text-xs text-white h-16 outline-none focus:border-blue-500"
                            placeholder="Dein Text hier..."
                         />
                         
                         <div className="flex items-center justify-between">
                            <span className="text-[10px] text-zinc-400 uppercase font-bold">Ausrichtung</span>
                            <div className="flex gap-1 bg-zinc-900 p-1 rounded border border-zinc-700">
                                <button onClick={() => onUpdateSurface(selectedSurface.id, { isVertical: false })} className={`px-2 py-1 text-[10px] rounded ${!selectedSurface.isVertical ? 'bg-blue-600 text-white' : 'text-zinc-500'}`}>Horizontal</button>
                                <button onClick={() => onUpdateSurface(selectedSurface.id, { isVertical: true })} className={`px-2 py-1 text-[10px] rounded ${selectedSurface.isVertical ? 'bg-blue-600 text-white' : 'text-zinc-500'}`}>Vertikal</button>
                            </div>
                         </div>

                         <div className="space-y-1">
                            <div className="flex justify-between text-[10px] text-zinc-400"><label>Schriftgröße</label><span>{selectedSurface.fontSize || 100}px</span></div>
                            <input type="range" min="10" max="300" step="5" value={selectedSurface.fontSize || 100} onChange={(e) => onUpdateSurface(selectedSurface.id, { fontSize: parseInt(e.target.value) })} className="w-full accent-blue-500 h-1 bg-zinc-700 rounded-lg appearance-none cursor-pointer"/>
                         </div>
                      </div>
                    )}

                    {selectedSurface.type === SurfaceType.VIDEO && (
                      <div className="bg-zinc-800/50 rounded p-2 mb-4 border border-zinc-700">
                         <div className="flex items-center mb-1 text-xs text-green-400 font-bold uppercase"><i className="fa-solid fa-volume-high mr-2"></i> Audio & Ton</div>
                         <div className="space-y-3">
                            <div className="space-y-1">
                                <div className="flex justify-between text-[10px] text-zinc-400"><label>Lautstärke</label><span>{Math.round((selectedSurface.volume ?? 1) * 100)}%</span></div>
                                <input type="range" min="0" max="1" step="0.05" value={selectedSurface.volume ?? 1} onChange={(e) => onUpdateSurface(selectedSurface.id, { volume: parseFloat(e.target.value) })} className="w-full accent-green-500 h-1 bg-zinc-700 rounded-lg appearance-none cursor-pointer"/>
                            </div>
                            <div className="flex items-center justify-between">
                                <span className="text-[10px] text-zinc-400 uppercase font-bold">Stummschalten</span>
                                <button onClick={() => onUpdateSurface(selectedSurface.id, { isMuted: !selectedSurface.isMuted })} className={`w-10 h-5 rounded-full relative transition-colors ${selectedSurface.isMuted ? 'bg-red-600' : 'bg-zinc-700'}`}>
                                    <div className={`absolute top-1 w-3 h-3 bg-white rounded-full transition-all ${selectedSurface.isMuted ? 'left-6' : 'left-1'}`}></div>
                                </button>
                            </div>
                         </div>
                      </div>
                    )}

                    <div className="flex bg-zinc-800 p-1 rounded border border-zinc-700 mb-4">
                        <button onClick={() => toggleMaskMode(false)} className={`flex-1 py-1.5 text-xs font-medium rounded transition-colors ${editMode === 'perspective' ? 'bg-blue-600 text-white' : 'text-zinc-400'}`}><i className="fa-solid fa-arrows-up-down-left-right mr-1"></i> 4-Punkt</button>
                        <button onClick={() => toggleMaskMode(true)} className={`flex-1 py-1.5 text-xs font-medium rounded transition-colors ${editMode === 'mask' ? 'bg-green-600 text-white' : 'text-zinc-400'}`}><i className="fa-solid fa-draw-polygon mr-1"></i> Maske</button>
                    </div>
                    {editMode === 'mask' && (
                        <div className="mb-4 p-2 bg-zinc-800/50 border border-green-900/30 rounded space-y-2">
                            <p className="text-[10px] text-zinc-400"><i className="fa-solid fa-info-circle mr-1"></i> Klicke auf <b>+</b> um Punkte hinzuzufügen.<br/>Doppelklick zum Löschen.</p>
                            <div className="flex gap-2"><button onClick={resetMask} className="flex-1 py-1 bg-zinc-700 rounded text-xs text-white">Reset Form</button><button onClick={clearMask} className="flex-1 py-1 bg-red-900/30 border border-red-900/50 rounded text-xs text-red-300">Maske löschen</button></div>
                        </div>
                    )}
                    <div className={`space-y-3 ${editMode === 'mask' ? 'opacity-50 pointer-events-none' : ''}`}>
                         <div className="space-y-1"><label className="text-xs text-zinc-400">Grundform</label><select value={selectedSurface.shape} onChange={(e) => onUpdateSurface(selectedSurface.id, { shape: e.target.value })} className="w-full bg-zinc-900 border border-zinc-700 rounded px-2 py-1.5 text-sm text-white outline-none"><option value="rect">Rechteck</option><option value="circle">Kreis</option><option value="triangle">Dreieck</option></select></div>
                         <div className="space-y-1"><div className="flex justify-between text-xs text-zinc-400"><label>Rotation</label><span>{selectedSurface.rotation || 0}°</span></div><input type="range" min="0" max="360" step="1" value={selectedSurface.rotation || 0} onChange={(e) => onUpdateSurface(selectedSurface.id, { rotation: parseInt(e.target.value) })} className="w-full accent-blue-500 h-1.5 bg-zinc-700 rounded-lg appearance-none cursor-pointer"/></div>
                         {(selectedSurface.type === SurfaceType.COLOR || selectedSurface.type === SurfaceType.LINE || selectedSurface.type === SurfaceType.TEXT) && (
                             <div className="space-y-1"><label className="text-xs text-zinc-400">Farbe</label><div className="flex gap-2"><input type="color" value={selectedSurface.src} onChange={(e) => onUpdateSurface(selectedSurface.id, { src: e.target.value })} className="w-8 h-8 rounded cursor-pointer border-none bg-transparent"/><input type="text" value={selectedSurface.src} onChange={(e) => onUpdateSurface(selectedSurface.id, { src: e.target.value })} className="flex-1 bg-zinc-900 border border-zinc-700 rounded px-2 text-sm text-white" /></div></div>
                         )}
                         {(selectedSurface.type === SurfaceType.LINE || selectedSurface.type === SurfaceType.IMAGE || selectedSurface.type === SurfaceType.COLOR || selectedSurface.type === SurfaceType.TEXT) && (
                            <div className="space-y-1">
                                <div className="flex justify-between text-xs text-zinc-400"><label>Animation</label><input type="checkbox" checked={!!selectedSurface.animationSpeed} onChange={(e) => onUpdateSurface(selectedSurface.id, { animationSpeed: e.target.checked ? 5 : 0, animationType: 'simple' })} /></div>
                                 {selectedSurface.animationSpeed ? (
                                     <>
                                        <input type="range" min="0.1" max="10" step="0.1" value={selectedSurface.animationSpeed} onChange={(e) => onUpdateSurface(selectedSurface.id, { animationSpeed: parseFloat(e.target.value) })} className="w-full accent-cyan-500 h-1 bg-zinc-700 rounded-lg appearance-none cursor-pointer"/>
                                        <div className="grid grid-cols-3 gap-1 mt-1">
                                            {[
                                                {id:'simple', n:'Standard'},
                                                {id:'shake', n:'Shake'},
                                                {id:'float', n:'Float'},
                                                {id:'blink', n:'Blink'},
                                                {id:'sway', n:'Sway'},
                                                {id:'scale', n:'Scale'},
                                                {id:'glitch', n:'Glitch'}
                                            ].map(anim => (
                                                <button key={anim.id} onClick={() => onUpdateSurface(selectedSurface.id, { animationType: anim.id })} className={`text-[8px] py-1 border rounded transition-colors uppercase font-bold ${selectedSurface.animationType === anim.id ? 'bg-blue-600 border-blue-500 text-white' : 'border-zinc-700 text-zinc-500 hover:bg-zinc-800'}`}>{anim.n}</button>
                                            ))}
                                            {(selectedSurface.type === SurfaceType.LINE || selectedSurface.type === SurfaceType.COLOR || selectedSurface.type === SurfaceType.IMAGE) && (
                                                <>
                                                    <button onClick={() => onUpdateSurface(selectedSurface.id, { animationType: 'chase' })} className={`text-[8px] py-1 border rounded uppercase font-bold ${selectedSurface.animationType==='chase' ? 'bg-blue-600 border-blue-500 text-white' : 'border-zinc-700 text-zinc-500 hover:bg-zinc-800'}`}>Lauflicht</button>
                                                    <button onClick={() => onUpdateSurface(selectedSurface.id, { animationType: 'draw' })} className={`text-[8px] py-1 border rounded uppercase font-bold ${selectedSurface.animationType==='draw' ? 'bg-blue-600 border-blue-500 text-white' : 'border-zinc-700 text-zinc-500 hover:bg-zinc-800'}`}>Aufbau</button>
                                                </>
                                            )}
                                            {selectedSurface.type === SurfaceType.IMAGE && (
                                                 <button onClick={() => onUpdateSurface(selectedSurface.id, { animationType: 'spin3d' })} className={`text-[8px] py-1 border rounded uppercase font-bold ${selectedSurface.animationType==='spin3d' ? 'bg-blue-600 border-blue-500 text-white' : 'border-zinc-700 text-zinc-500 hover:bg-zinc-800'}`}>3D Spin</button>
                                            )}
                                            {selectedSurface.type === SurfaceType.TEXT && (
                                                <>
                                                 <button onClick={() => onUpdateSurface(selectedSurface.id, { animationType: 'pulse' })} className={`text-[8px] py-1 border rounded uppercase font-bold ${selectedSurface.animationType==='pulse' ? 'bg-blue-600 border-blue-500 text-white' : 'border-zinc-700 text-zinc-500 hover:bg-zinc-800'}`}>Pulsieren</button>
                                                 <button onClick={() => onUpdateSurface(selectedSurface.id, { animationType: 'flip' })} className={`text-[8px] py-1 border rounded uppercase font-bold ${selectedSurface.animationType==='flip' ? 'bg-blue-600 border-blue-500 text-white' : 'border-zinc-700 text-zinc-500 hover:bg-zinc-800'}`}>3D Flip</button>
                                                </>
                                            )}
                                        </div>
                                     </>
                                 ) : null}
                            </div>
                        )}
                        {selectedSurface.type === SurfaceType.LINE && (
                            <div className="space-y-1"><div className="flex justify-between text-xs text-zinc-400"><label>Linienbreite</label><span>{selectedSurface.lineWidth || 10}px</span></div><input type="range" min="1" max="100" value={selectedSurface.lineWidth || 10} onChange={(e) => onUpdateSurface(selectedSurface.id, { lineWidth: parseInt(e.target.value) })} className="w-full accent-cyan-500 h-1.5 bg-zinc-700 rounded-lg appearance-none cursor-pointer"/></div>
                        )}
                        <div className="space-y-1"><label className="text-xs text-zinc-400">Deckkraft</label><input type="range" min="0" max="1" step="0.01" value={selectedSurface.opacity} onChange={(e) => onUpdateSurface(selectedSurface.id, { opacity: parseFloat(e.target.value) })} className="w-full accent-blue-500 h-1.5 bg-zinc-700 rounded-lg appearance-none"/></div>
                    </div>
                  </div>
                )}
              </div>
              <div className="bg-zinc-950 border-t border-zinc-800 p-4">
                  <div className="flex items-center justify-between mb-2"><span className="text-xs text-zinc-500 font-mono">{formatTime(currentTime)}</span><div className="flex gap-2">{!isPlaying ? (<button onClick={onPlay} className="w-8 h-8 rounded-full bg-green-600 hover:bg-green-500 text-white flex items-center justify-center transition-colors"><i className="fa-solid fa-play"></i></button>) : (<button onClick={onStop} className="w-8 h-8 rounded-full bg-yellow-600 hover:bg-yellow-500 text-white flex items-center justify-center transition-colors"><i className="fa-solid fa-pause"></i></button>)}<button onClick={onReset} className="w-8 h-8 rounded-full bg-zinc-800 hover:bg-zinc-700 text-white flex items-center justify-center transition-colors"><i className="fa-solid fa-stop"></i></button></div></div>
                  <div className="h-1 bg-zinc-800 rounded overflow-hidden"><div className="h-full bg-blue-500 w-full animate-pulse opacity-20"></div></div>
              </div>
            </div>
          );
        };

        const App = () => {
          const [surfaces, setSurfaces] = useState([]); const [selectedId, setSelectedId] = useState(null);
          const [isUIHidden, setIsUIHidden] = useState(false); const [editMode, setEditMode] = useState('perspective');
          const [isPlaying, setIsPlaying] = useState(false); const [currentTime, setCurrentTime] = useState(0);
          const [showPlayModal, setShowPlayModal] = useState(false);
          const [playConfig, setPlayConfig] = useState({ loopDuration: 30, mode: 'infinite', count: 1, stopAfter: 60 });
          const [playLoopCount, setPlayLoopCount] = useState(0);
          const [showWindowDrawing, setShowWindowDrawing] = useState(false);
          const [showScreenDrawing, setShowScreenDrawing] = useState(false);
          const timerRef = useRef(null);
          const [draggingHandle, setDraggingHandle] = useState(null); const [draggingSurface, setDraggingSurface] = useState(null);
          const [lastMousePos, setLastMousePos] = useState(null); const containerRef = useRef(null);

          const getMaxDuration = () => { let max = 10; surfaces.forEach(s => { const end = (s.timelineStart || 0) + (s.timelineDuration || 10); if (end > max) max = end; }); return max; };
          const handleOpenPlayModal = () => { setPlayConfig(prev => ({ ...prev, loopDuration: getMaxDuration() })); setShowPlayModal(true); };
          const handleStartPlayback = () => { setShowPlayModal(false); setIsPlaying(true); setPlayLoopCount(0); setCurrentTime(0); setSelectedId(null); };
          const handleStop = () => setIsPlaying(false); const handleReset = () => { setIsPlaying(false); setCurrentTime(0); };

          useEffect(() => {
              if (isPlaying) {
                  const startTime = Date.now() - (currentTime * 1000); const startTimestamp = Date.now();
                  timerRef.current = window.setInterval(() => {
                      const now = Date.now(); const rawTime = (now - startTime) / 1000;
                      if (playConfig.mode === 'timer' && (now - startTimestamp)/1000 >= playConfig.stopAfter) { handleStop(); return; }
                      if (playConfig.loopDuration > 0 && rawTime >= playConfig.loopDuration) { if (playConfig.mode === 'count') { const newLoopCount = playLoopCount + 1; if (newLoopCount >= playConfig.count) { handleStop(); return; } setPlayLoopCount(newLoopCount); } }
                      if (playConfig.loopDuration > 0) setCurrentTime(rawTime % playConfig.loopDuration); else setCurrentTime(rawTime);
                  }, 50);
              } else { if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; } }
              return () => { if (timerRef.current) clearInterval(timerRef.current); };
          }, [isPlaying, playConfig, playLoopCount]);

          const getLocalPos = useCallback((clientX, clientY) => { if (!containerRef.current) return { x: clientX, y: clientY }; const rect = containerRef.current.getBoundingClientRect(); return { x: clientX - rect.left, y: clientY - rect.top }; }, []);
          const handleAddSurface = (type, src, shape = 'rect', initialWidth = 300, initialHeight = 300, duration = 0, customCx = null, customCy = null) => {
            if (!containerRef.current) return; const rect = containerRef.current.getBoundingClientRect();
            const cx = customCx !== null ? customCx : (rect.width / 2); const cy = customCy !== null ? customCy : (rect.height / 2);
            const halfW = initialWidth / 2; const halfH = initialHeight / 2;
            const newSurface = {
              id: uuidv4(), name: `${type === 'TEXT' ? 'Text' : 'Fläche'} ${surfaces.length + 1}`, type, shape, src,
              corners: [{ x: cx - halfW, y: cy - halfH }, { x: cx + halfW, y: cy - halfH }, { x: cx + halfW, y: cy + halfH }, { x: cx - halfW, y: cy + halfH }],
              opacity: 1, visible: true, zIndex: surfaces.length + 1, lineWidth: 10, animationSpeed: 0, animationType: 'simple', isMuted: false, volume: 1, 
              timelineStart: 0, timelineDuration: 10, rotation: 0, videoDuration: duration, loopMode: 'infinite', loopCount: 1,
              textContent: type === 'TEXT' ? 'PROJECTION' : '', fontSize: type === 'TEXT' ? 80 : 0, isVertical: false
            };
            setSurfaces(prev => [...prev, newSurface]); setSelectedId(newSurface.id); setEditMode('perspective'); return newSurface;
          };
          
          const handleSaveWindowDrawing = (dataUrl) => {
              setShowWindowDrawing(false);
              const newSurface = handleAddSurface(SurfaceType.IMAGE, dataUrl, 'rect', 500, 500);
              if (newSurface) handleUpdateSurface(newSurface.id, { animationSpeed: 4, animationType: 'simple', name: 'Zeichnung' });
          };
          
          const handleSaveScreenDrawing = (dataUrl, rect) => {
              setShowScreenDrawing(false); if (!containerRef.current) return; const containerRect = containerRef.current.getBoundingClientRect();
              const gCx = rect.x + (rect.w / 2); const gCy = rect.y + (rect.h / 2); const lCx = gCx - containerRect.left; const lCy = gCy - containerRect.top;
              const newSurface = handleAddSurface(SurfaceType.IMAGE, dataUrl, 'rect', rect.w, rect.h, 0, lCx, lCy);
              if (newSurface) handleUpdateSurface(newSurface.id, { animationSpeed: 5, animationType: 'simple', name: 'Direkt-Zeichnung' });
          };

          const handleUpdateSurface = (id, updates) => setSurfaces(prev => prev.map(s => s.id === id ? { ...s, ...updates } : s));
          const handleDeleteSurface = (id) => { setSurfaces(prev => prev.filter(s => s.id !== id)); if (selectedId === id) setSelectedId(null); };
          const handleLoadProject = (loaded) => { if(Array.isArray(loaded)){ setSurfaces(loaded); setSelectedId(null); } };
          const handleMouseDown = (e) => { if (isPlaying) return; if (e.target === containerRef.current) setSelectedId(null); };
          const getEventClientPos = (e) => { if ('touches' in e) return { x: e.touches[0].clientX, y: e.touches[0].clientY }; return { x: e.clientX, y: e.clientY }; };
          const handleHandleStart = (e, surfaceId, index, isMask) => { if (isPlaying) return; e.stopPropagation(); if ('touches' in e) e.preventDefault(); setDraggingHandle({ surfaceId, index, isMask }); setSelectedId(surfaceId); };
          const handleHandleDoubleClick = (e, surfaceId, index, isMask) => { if (isPlaying) return; e.stopPropagation(); if (!isMask) return; const s = surfaces.find(s => s.id === surfaceId); if (!s || !s.maskPoints || s.maskPoints.length <= 3) return; const newMask = [...s.maskPoints]; newMask.splice(index, 1); handleUpdateSurface(surfaceId, { maskPoints: newMask }); };
          const handleGhostStart = (e, surfaceId, insertIndex) => { if (isPlaying) return; e.stopPropagation(); if ('touches' in e) e.preventDefault(); const s = surfaces.find(s => s.id === surfaceId); if (!s || !s.maskPoints) return; const len = s.maskPoints.length; const prevIndex = (insertIndex - 1 + len) % len; const p1 = s.maskPoints[prevIndex]; const p2 = s.maskPoints[insertIndex % len]; const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 }; const newMask = [...s.maskPoints]; newMask.splice(insertIndex, 0, midPoint); handleUpdateSurface(surfaceId, { maskPoints: newMask }); setDraggingHandle({ surfaceId, index: insertIndex, isMask: true }); setSelectedId(surfaceId); };
          const handleSurfaceStart = (e, surfaceId) => { if (isPlaying) return; if (draggingHandle) return; e.stopPropagation(); if ('touches' in e) e.preventDefault(); const { x, y } = getEventClientPos(e); setSelectedId(surfaceId); setDraggingSurface(surfaceId); setLastMousePos(getLocalPos(x, y)); };

          const processMove = useCallback((clientX, clientY) => {
            if (isPlaying) return; const mousePos = getLocalPos(clientX, clientY);
            if (draggingHandle) {
              setSurfaces(prev => prev.map(s => {
                if (s.id !== draggingHandle.surfaceId) return s;
                if (draggingHandle.isMask) { const newMask = [...s.maskPoints]; if (newMask[draggingHandle.index]) newMask[draggingHandle.index] = mousePos; return { ...s, maskPoints: newMask }; }
                else { const newCorners = [...s.corners]; newCorners[draggingHandle.index] = mousePos; return { ...s, corners: newCorners }; }
              }));
            } else if (draggingSurface && lastMousePos) {
                const dx = mousePos.x - lastMousePos.x; const dy = mousePos.y - lastMousePos.y;
                setSurfaces(prev => prev.map(s => {
                    if (s.id !== draggingSurface) return s;
                    const newCorners = s.corners.map(p => ({ x: p.x + dx, y: p.y + dy }));
                    let newMaskPoints = s.maskPoints; if (s.maskPoints) newMaskPoints = s.maskPoints.map(p => ({ x: p.x + dx, y: p.y + dy }));
                    return { ...s, corners: newCorners, maskPoints: newMaskPoints };
                }));
                setLastMousePos(mousePos);
            }
          }, [draggingHandle, draggingSurface, lastMousePos, getLocalPos, isPlaying]);

          useEffect(() => {
            const handleMouseMove = (e) => processMove(e.clientX, e.clientY);
            const handleTouchMove = (e) => { if (draggingHandle || draggingSurface) e.preventDefault(); processMove(e.touches[0].clientX, e.touches[0].clientY); };
            const handleEnd = () => { setDraggingHandle(null); setDraggingSurface(null); setLastMousePos(null); };
            window.addEventListener('mousemove', handleMouseMove); window.addEventListener('mouseup', handleEnd); window.addEventListener('touchmove', handleTouchMove, { passive: false }); window.addEventListener('touchend', handleEnd);
            return () => { window.removeEventListener('mousemove', handleMouseMove); window.removeEventListener('mouseup', handleEnd); window.removeEventListener('touchmove', handleTouchMove); window.removeEventListener('touchend', handleEnd); };
          }, [processMove, draggingHandle, draggingSurface]);

          useEffect(() => {
            const handleKeyDown = (e) => { if (['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) return; if (e.key === 'Escape') setSelectedId(null); if (e.key === 'Delete' || e.key === 'Backspace') { if (selectedId && !isPlaying) handleDeleteSurface(selectedId); } if (e.key === 'h') setIsUIHidden(prev => !prev); };
            window.addEventListener('keydown', handleKeyDown); return () => window.removeEventListener('keydown', handleKeyDown);
          }, [selectedId, isPlaying]);

          const toggleFullscreen = () => { if (!document.fullscreenElement) document.documentElement.requestFullscreen(); else document.exitFullscreen(); };
          const selectedSurface = surfaces.find(s => s.id === selectedId);

          return (
            <div className="flex w-full overflow-hidden relative font-sans text-gray-200" style={{ height: '100dvh' }}>
              
              {showPlayModal && (
                  <div className="absolute inset-0 bg-black/80 z-[300] flex items-center justify-center p-4">
                      <div className="w-full max-w-sm bg-zinc-900 border border-zinc-700 rounded-lg p-5 shadow-2xl">
                          <h3 className="text-lg font-bold text-white mb-4 border-b border-zinc-800 pb-2">Sequenz-Einstellung</h3>
                          <div className="space-y-4 mb-6">
                              <div><label className="text-xs text-zinc-400 block mb-1 uppercase font-bold">Länge (Sekunden)</label><input type="number" min="1" step="0.1" value={playConfig.loopDuration} onChange={(e) => setPlayConfig(prev => ({...prev, loopDuration: parseFloat(e.target.value)}))} className="w-full bg-black border border-zinc-700 rounded px-3 py-2 text-white outline-none focus:border-blue-500" /></div>
                              <div>
                                  <label className="text-xs text-zinc-400 block mb-1 uppercase font-bold">Modus</label>
                                  <div className="flex flex-col gap-2">
                                      <label className="flex items-center gap-2 p-2 rounded bg-zinc-800 border border-zinc-700 cursor-pointer transition-colors hover:bg-zinc-700">
                                          <input type="radio" name="playMode" checked={playConfig.mode === 'infinite'} onChange={() => setPlayConfig(prev => ({...prev, mode: 'infinite'}))} className="accent-green-500"/>
                                          <span className="text-sm">Unendlich</span>
                                      </label>
                                      <div className={`p-2 rounded border border-zinc-700 transition-colors ${playConfig.mode === 'count' ? 'bg-zinc-800 border-green-900' : 'bg-zinc-900'}`}>
                                          <label className="flex items-center gap-2 cursor-pointer mb-2">
                                              <input type="radio" name="playMode" checked={playConfig.mode === 'count'} onChange={() => setPlayConfig(prev => ({...prev, mode: 'count'}))} className="accent-green-500"/>
                                              <span className="text-sm">Anzahl Durchläufe:</span>
                                          </label>
                                          {playConfig.mode === 'count' && <input type="number" min="1" value={playConfig.count} onChange={(e) => setPlayConfig(prev => ({...prev, count: parseInt(e.target.value)}))} className="w-full bg-black border border-zinc-700 rounded px-2 py-1 text-sm text-white focus:border-green-500 outline-none"/>}
                                      </div>
                                      <div className={`p-2 rounded border border-zinc-700 transition-colors ${playConfig.mode === 'timer' ? 'bg-zinc-800 border-green-900' : 'bg-zinc-900'}`}>
                                          <label className="flex items-center gap-2 cursor-pointer mb-2">
                                              <input type="radio" name="playMode" checked={playConfig.mode === 'timer'} onChange={() => setPlayConfig(prev => ({...prev, mode: 'timer'}))} className="accent-green-500"/>
                                              <span className="text-sm">Stop nach Zeit (Sek):</span>
                                          </label>
                                          {playConfig.mode === 'timer' && <input type="number" min="1" value={playConfig.stopAfter} onChange={(e) => setPlayConfig(prev => ({...prev, stopAfter: parseInt(e.target.value)}))} className="w-full bg-black border border-zinc-700 rounded px-2 py-1 text-sm text-white focus:border-green-500 outline-none"/>}
                                      </div>
                                  </div>
                              </div>
                          </div>
                          <div className="flex gap-3"><button onClick={() => setShowPlayModal(false)} className="flex-1 py-2 bg-zinc-800 rounded text-zinc-300 font-bold">Abbruch</button><button onClick={handleStartPlayback} className="flex-1 py-2 bg-green-600 rounded text-white font-bold shadow-lg shadow-green-900/20">Wiedergeben</button></div>
                      </div>
                  </div>
              )}

              {showWindowDrawing && <DrawingModal onClose={() => setShowWindowDrawing(false)} onSave={handleSaveWindowDrawing} />}
              {showScreenDrawing && <ScreenDrawingOverlay onClose={() => setShowScreenDrawing(false)} onSave={handleSaveScreenDrawing} />}
              <div className={`absolute left-0 top-0 h-full max-w-full transition-transform duration-300 z-[100] ${isUIHidden ? '-translate-x-full' : 'translate-x-0'}`}>
                <Sidebar surfaces={surfaces} selectedId={selectedId} editMode={editMode} onSetEditMode={setEditMode} onAddSurface={handleAddSurface} onSelect={setSelectedId} onUpdateSurface={handleUpdateSurface} onDeleteSurface={handleDeleteSurface} onLoadProject={handleLoadProject} onToggleFullscreen={toggleFullscreen} onCloseMobile={() => setIsUIHidden(true)} isPlaying={isPlaying} currentTime={currentTime} onPlay={handleOpenPlayModal} onStop={handleStop} onReset={handleReset} onOpenWindowDrawing={() => setShowWindowDrawing(true)} onOpenScreenDrawing={() => setShowScreenDrawing(true)} />
              </div>
              <div className={`absolute top-4 left-4 z-[90] transition-opacity duration-300 ${isUIHidden ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}><button onClick={() => setIsUIHidden(false)} className="w-10 h-10 bg-zinc-800 rounded-full flex items-center justify-center text-white shadow-lg border border-zinc-700 hover:bg-zinc-700 transition"><i className="fa-solid fa-bars"></i></button></div>
              <div ref={containerRef} className="flex-1 relative bg-black cursor-crosshair overflow-hidden w-full h-full touch-none" onMouseDown={handleMouseDown}>
                {surfaces.map(surface => <SurfaceLayer key={surface.id} surface={surface} isSelected={selectedId === surface.id && !isUIHidden} onSelect={(id) => { if(!isUIHidden && !isPlaying) setSelectedId(id); }} isPlaying={isPlaying} globalTime={currentTime}/>)}
                {selectedSurface && !isUIHidden && !isPlaying && (
                  <div className="absolute inset-0 pointer-events-none z-[200]">
                    {editMode === 'perspective' && (
                        <>
                            <svg className="absolute inset-0 w-full h-full overflow-visible pointer-events-none"><path d={`M ${selectedSurface.corners[0].x} ${selectedSurface.corners[0].y} L ${selectedSurface.corners[1].x} ${selectedSurface.corners[1].y} L ${selectedSurface.corners[2].x} ${selectedSurface.corners[2].y} L ${selectedSurface.corners[3].x} ${selectedSurface.corners[3].y} Z`} fill="none" stroke="#3b82f6" strokeWidth="1" strokeDasharray="4 2"/></svg>
                            {selectedSurface.corners.map((corner, idx) => <div key={`c-${idx}`} className="absolute w-8 h-8 bg-blue-500/50 border-2 border-white rounded-full shadow cursor-move pointer-events-auto flex items-center justify-center backdrop-blur-sm transition-transform hover:scale-110" style={{ left: corner.x - 16, top: corner.y - 16 }} onMouseDown={(e) => handleHandleStart(e, selectedSurface.id, idx, false)} onTouchStart={(e) => handleHandleStart(e, selectedSurface.id, idx, false)}><div className="w-2 h-2 bg-white rounded-full" /></div>)}
                            <div className="absolute w-10 h-10 bg-white/20 border border-white/50 rounded-full cursor-grab pointer-events-auto flex items-center justify-center backdrop-blur-sm" style={{ left: (selectedSurface.corners[0].x + selectedSurface.corners[2].x) / 2 - 20, top: (selectedSurface.corners[0].y + selectedSurface.corners[2].y) / 2 - 20 }} onMouseDown={(e) => handleSurfaceStart(e, selectedSurface.id)} onTouchStart={(e) => handleSurfaceStart(e, selectedSurface.id)}><i className="fa-solid fa-arrows-up-down-left-right text-sm text-white"></i></div>
                        </>
                    )}
                    {editMode === 'mask' && selectedSurface.maskPoints && (
                        <>
                            <svg className="absolute inset-0 w-full h-full overflow-visible pointer-events-none"><polygon points={selectedSurface.maskPoints.map(p => `${p.x},${p.y}`).join(' ')} fill="none" stroke="#22c55e" strokeWidth="2"/></svg>
                            {selectedSurface.maskPoints.map((point, idx) => {
                                const nextIdx = (idx + 1) % selectedSurface.maskPoints.length; const nextPoint = selectedSurface.maskPoints[nextIdx];
                                const midX = (point.x + nextPoint.x) / 2; const midY = (point.y + nextPoint.y) / 2;
                                return (
                                    <React.Fragment key={`m-${idx}`}>
                                        <div className="absolute w-6 h-6 bg-green-500 border-2 border-white rounded-sm shadow cursor-move pointer-events-auto flex items-center justify-center z-10 hover:scale-110 transition-transform" style={{ left: point.x - 12, top: point.y - 12 }} onMouseDown={(e) => handleHandleStart(e, selectedSurface.id, idx, true)} onTouchStart={(e) => handleHandleStart(e, selectedSurface.id, idx, true)} onDoubleClick={(e) => handleHandleDoubleClick(e, selectedSurface.id, idx, true)} />
                                        <div className="absolute w-5 h-5 bg-green-500/30 border border-green-300 rounded-full cursor-pointer pointer-events-auto flex items-center justify-center z-0 transition-all hover:bg-green-500 hover:scale-110" style={{ left: midX - 10, top: midY - 10 }} onMouseDown={(e) => handleGhostStart(e, selectedSurface.id, nextIdx)} onTouchStart={(e) => handleGhostStart(e, selectedSurface.id, nextIdx)}><i className="fa-solid fa-plus text-[10px] text-white"></i></div>
                                    </React.Fragment>
                                );
                            })}
                        </>
                    )}
                  </div>
                )}
              </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

