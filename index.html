<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Projection Mapping Tool - Non-Commercial</title>
    
    <!-- Lizenzen: 
         - Eigenes Werk: CC BY-NC-SA 4.0
         - React: MIT License
         - Tailwind: MIT License
         - FontAwesome: CC BY 4.0 / FontAwesome Free License
         - Babel: MIT License
    -->
    
    <!-- Privacy Meta Tags -->
    <meta name="privacy" content="no-tracking, no-data-collection, local-processing-only">
    <meta name="data-collection" content="none">
    <meta name="description" content="Client-seitiges Projection-Mapping Tool - Alle Daten bleiben lokal auf Ihrem Gerät">
    
    <!-- License Information -->
    <meta name="license" content="CC BY-NC-SA 4.0">
    <meta name="copyright" content="© 2024 Projection Mapping Tool - Nur nicht-kommerzielle Nutzung">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Custom Styles -->
    <style>
      /* Reset & Base */
      html, body {
        background-color: #000;
        color: #fff;
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        overscroll-behavior: none;
        touch-action: none;
      }

      .no-scrollbar::-webkit-scrollbar { display: none; }
      .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

      /* GPU Acceleration Class */
      .gpu-accelerated {
          will-change: transform;
          transform: translateZ(0);
          backface-visibility: hidden;
          transform-style: preserve-3d;
      }
      
      .effect-preview {
        background-image: linear-gradient(45deg, #333 25%, transparent 25%), linear-gradient(-45deg, #333 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #333 75%), linear-gradient(-45deg, transparent 75%, #333 75%);
        background-size: 20px 20px;
        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        overflow: hidden;
        position: relative;
      }
      .effect-preview::before {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(45deg, #ff00ff, #00ffff);
        mix-blend-mode: screen;
      }

      /* --- CORE ANIMATIONS --- */
      .animate-glow { animation: neon-pulse 2s infinite linear; }
      .animate-dash { animation: dash-cycle 2s infinite linear; }
      .animate-draw { 
          animation-name: draw-stroke;
          animation-iteration-count: 1;
          animation-fill-mode: forwards;
          animation-timing-function: linear; 
      }
      .animate-hue { animation: hue-cycle 5s infinite linear; }
      .animate-spin-3d { 
          animation: spin-3d 5s infinite linear; 
          transform-style: preserve-3d;
      }
      .animate-text-3d {
          animation: text-3d-complex 6s infinite ease-in-out;
          transform-style: preserve-3d;
          display: inline-block;
      }
      .animate-text-pulse {
          animation: text-pulse-glow 2s infinite ease-in-out;
          display: inline-block;
      }
      .animate-text-flip {
          animation: text-flip-3d 4s infinite linear;
          transform-style: preserve-3d;
          display: inline-block;
      }
      .animate-image-chase {
          mask-image: repeating-linear-gradient(90deg, black 0%, black 25%, transparent 25%, transparent 50%);
          -webkit-mask-image: repeating-linear-gradient(90deg, black 0%, black 25%, transparent 25%, transparent 50%);
          mask-size: 200% 100%;
          -webkit-mask-size: 200% 100%;
          animation: mask-scroll 2s infinite linear;
      }
      .animate-image-draw {
          animation: reveal-wipe 2s forwards linear; 
      }
      .animate-scanner { 
          background-size: 200% 100% !important; 
          animation: scanner-swipe 2s infinite linear; 
      }
      .animate-shake { animation: shake 0.5s infinite ease-in-out; }
      .animate-float { animation: float 3s infinite ease-in-out; }
      .animate-blink { animation: blink 1s infinite steps(1); }
      .animate-sway { animation: sway 4s infinite ease-in-out; transform-origin: top center; }
      .animate-scale { animation: scale-pulse 2s infinite ease-in-out; }
      .animate-glitch { animation: glitch 0.3s infinite linear; }

      /* --- CORE KEYFRAMES --- */
      @keyframes neon-pulse { 0% { filter: drop-shadow(0 0 2px) hue-rotate(0deg); opacity: 0.8; } 50% { filter: drop-shadow(0 0 10px) hue-rotate(180deg); opacity: 1; } 100% { filter: drop-shadow(0 0 2px) hue-rotate(360deg); opacity: 0.8; } }
      @keyframes hue-cycle { 0% { filter: hue-rotate(0deg); } 100% { filter: hue-rotate(360deg); } }
      @keyframes dash-cycle { to { stroke-dashoffset: -1000; } }
      @keyframes draw-stroke { to { stroke-dashoffset: 0; } }
      @keyframes scanner-swipe { 0% { background-position: 100% 0; } 100% { background-position: -100% 0; } }
      @keyframes spin-3d { 0% { transform: rotateY(0deg) rotateX(10deg); } 100% { transform: rotateY(360deg) rotateX(10deg); } }
      @keyframes text-3d-complex { 0% { transform: translate3d(0, 0, 0) rotate3d(1, 1, 1, 0deg) scale3d(1, 1, 1); } 25% { transform: translate3d(20px, -10px, 50px) rotate3d(0, 1, 0.5, 45deg) scale3d(1.1, 1.1, 1.1); } 50% { transform: translate3d(0, 20px, 100px) rotate3d(1, 0.2, 0, 180deg) scale3d(0.9, 0.9, 0.9); } 75% { transform: translate3d(-20px, -10px, 50px) rotate3d(0, -1, 0.5, 270deg) scale3d(1.2, 1.2, 1.2); } 100% { transform: translate3d(0, 0, 0) rotate3d(1, 1, 1, 360deg) scale3d(1, 1, 1); } }
      @keyframes text-pulse-glow { 0%, 100% { transform: scale(1); filter: drop-shadow(0 0 5px currentColor); opacity: 0.8; } 50% { transform: scale(1.1); filter: drop-shadow(0 0 20px currentColor); opacity: 1; } }
      @keyframes text-flip-3d { 0% { transform: rotateY(0deg); } 100% { transform: rotateY(360deg); } }
      @keyframes reveal-wipe { 0% { clip-path: inset(0 100% 0 0); } 100% { clip-path: inset(0 0 0 0); } }
      @keyframes mask-scroll { 0% { mask-position: 100% 0; -webkit-mask-position: 100% 0; } 100% { mask-position: -100% 0; -webkit-mask-position: -100% 0; } }
      @keyframes shake { 0%, 100% { transform: translate(0, 0); } 25% { transform: translate(-5px, 5px); } 50% { transform: translate(5px, -5px); } 75% { transform: translate(-5px, -5px); } }
      @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-30px); } }
      @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
      @keyframes sway { 0%, 100% { transform: rotate(-8deg); } 50% { transform: rotate(8deg); } }
      @keyframes scale-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.15); } }
      @keyframes glitch { 0% { clip-path: inset(20% 0 30% 0); transform: translate(-5px, 5px); } 20% { clip-path: inset(60% 0 10% 0); transform: translate(5px, -5px); } 40% { clip-path: inset(40% 0 50% 0); transform: translate(-5px, 0px); } 60% { clip-path: inset(80% 0 5% 0); transform: translate(5px, 5px); } 80% { clip-path: inset(10% 0 70% 0); transform: translate(-5px, -5px); } 100% { clip-path: inset(0 0 0 0); transform: translate(0); } }

      /* --- VISUAL EFFECTS LIBRARY --- */
      .effect-container { width: 100%; height: 100%; transform-style: preserve-3d; }
      .effect-invert { filter: invert(1); }
      .effect-blur { filter: blur(8px); }
      .effect-sepia { filter: sepia(1); }
      .effect-saturate { filter: saturate(4); }
      .effect-grayscale { filter: grayscale(1); }
      .effect-contrast { filter: contrast(2); }
      .effect-brightness { filter: brightness(1.8); }
      .effect-hue-shift { animation: hue-cycle 3s infinite linear; }
      .effect-neon-shadow { filter: drop-shadow(0 0 10px #0ff) drop-shadow(0 0 20px #f0f); }
      .effect-skew { transform: skew(15deg, 10deg); }
      .effect-3d-xtilt { transform: perspective(500px) rotateX(45deg); }
      .effect-3d-ytilt { transform: perspective(500px) rotateY(45deg); }
      .effect-wobble { animation: wobble-effect 1s infinite ease-in-out; }
      .effect-flicker { animation: flicker-effect 0.2s infinite steps(1); }
      .effect-tv-static::after { content:""; position: absolute; inset: 0; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAAG3RSTlNAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAvEOwtAAAFVklEQVR4XpWWB67c2BUFb3g557T/hRo9/WUMZHlgr4Bg8Z4qQgQJlHI4A8SzFVrapvmTF9O7dmYRFZ60YiBhJRCgh1FYhiLAmdvX0Cz2pk01RsmQSupKUqyaj9zUAUmsgBgewdwPAA4fWhUysLQGszPSVBnws3OTOPUHFNLIWNirEwNg9kMSsyXKqdiFRJRsRNkwpD/GGf5laKUhyc2YG0UjGazvAAsian4ea7JsdeCz69/CGCZXdsSAQVfOkeBgZrW2EGa4lA33npkxv54tJtUgDGCeAANB8k9WGg/wU9zHcR/NZbLSWM5K5bMQmAoEMPT3T6UoUEdmgCkB4BOD0DCDD8F5BKgCASo4wjIABJGQ5cmRTss7/Y9ePE2Yss+gAZEOQBPK2,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAAG3RSTlNAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAvEOwtAAAFVklEQVR4XpWWB67c2BUFb3g557T/hRo9/WUMZHlgr4Bg8Z4qQgQJlHI4A8SzFVrapvmTF9O7dmYRFZ60YiBhJRCgh1FYhiLAmdvX0Cz2pk01RsmQSupKUuya9zUAUmsgBgewdwPAa4fWhUysLQGszPSVBnws3OTOPUHFNLIWNirEwNg9kMSsyXKqdiFRJRsRNkwpD/GGf5laKUhyc2YG0UjGazvAAsian4ea7JsdeCz69/CGCZXdsSAQVfOkeBgZrW2EGa4lA33npkxv54tJtUgDGCeAANB8k9WGg/wU9zHcR/NZbLSWM5K5bMQmAoEMPT3T6UoUEdmgCkB4BOD0DCDD8F5BKgCASo4wjIABJGQ5cmRTss7/Y9ePE2Yss+gAZEOQBPK2,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAAG3RSTlNAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAvEOwtAAAFVklEQVR4XpWWB67c2BUFb3g557T/hRo9/WUMZHlgr4Bg8Z4qQgQJlHI4A8SzFVrapvmTF9O7dmYRFZ60YiBhJRCgh1FYhiLAmdvX0Cz2pk01RsmQSupKUqyaj9zUAUmsgBgewdwPAa4fWhUysLQGszPSVBnws3OTOPUHFNLIWNirEwNg9kMSsyXKqdiFRJRsRNkwpD/GGf5laKUhyc2YG0UjGazvAAsian4ea7JsdeCz69/CGCZXdsSAQVfOkeBgZrW2EGa4lA33npkxv54tJtUgDGCeAANB8k9WGg/wU9zHcR/NZbLSWM5K5bMQmAoEMPT3T6UoUEdmgCkB4BOD0DCDD8F5BKgCASo4wjIABJGQ5cmRTss7/Y9ePE2Yss+gAZEOQBPK2); animation: tv-static-effect 0.1s infinite steps(1); opacity: 0.3; }
      .effect-chromatic-aberration::before, .effect-chromatic-aberration::after { content:""; position: absolute; inset: 0; background: inherit; background-size: cover; mix-blend-mode: screen; }
      .effect-chromatic-aberration::before { transform: translateX(-2px); filter: brightness(1.2); background-color: rgba(255,0,0,0.5); }
      .effect-chromatic-aberration::after { transform: translateX(2px); filter: brightness(1.2); background-color: rgba(0,0,255,0.5); }
      .effect-pixelate { filter: url(#pixelate-filter); }
      .effect-spotlight { mask-image: radial-gradient(circle at center, black 20%, transparent 60%); -webkit-mask-image: radial-gradient(circle at center, black 20%, transparent 60%); }
      .effect-vcr-glitch { animation: vcr-glitch-effect 0.5s infinite linear; }
      .effect-heatwave { filter: url(#heatwave-filter); }
      .effect-film-grain::after { content:""; position: absolute; inset: 0; background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAXRJREFUaIHtmLFxwjAUhL+rATsBNwI3AStBOwE7AStBOwE7ATsBOwHoBGwEZwQyB5vce/MkKTk/dJ8x39f5dS+5l6goykYABiAABiAABiAABiAABiAABiAABiCA/1Cj0ehkPpltY8vVag2G8W24mA4fJp2kHeV6vR61Wu3y3U4XxmNmiYBSs9lslEwms0Sv1w8vX2K72d/t9Xo9TqdToVAYhUKBsij6y6lUamI0GvU4nI6iKCrK8vLy8vJ+v1/5fL5aLBYOhwPFYpGGoijGmM+dAMACWFlYFG1f930eAQCqOgwGg+q6riwWizI2kM1mMxgMaL/f7w+stixLIgRB3/dJo9F0eZ53MhkyxrIs+p+maZpGIpEkGo163u8AgBwOh0KhUPE8z/M8z/M8z/M8z/M8z/M8z/M8z/M8z/M8z/M8z/P8P8An/QFJCGd2+w2gLwAAAABJRU5ErkJggg==); animation: film-grain-effect 0.2s steps(1) infinite; opacity: 0.15; }
      .effect-tunnel-vision { animation: tunnel-effect 4s infinite linear; }
      .effect-page-curl::after { content: ''; position: absolute; bottom: 0; right: 0; width: 50%; height: 50%; background: linear-gradient(-135deg, transparent 50%, #555 50%); filter: drop-shadow(-5px 5px 5px rgba(0,0,0,0.5)); }
      .effect-kaleidoscope { clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); transform: scale(1.5); }
      .effect-edge-detect { filter: url(#edge-detect-filter); }
      .effect-emboss { filter: url(#emboss-filter); }
      .effect-sharpen { filter: url(#sharpen-filter); }
      .effect-slit-scan { animation: slit-scan-effect 3s infinite ease-in-out; background-size: 100% 200% !important; }
      .effect-rgb-split { animation: rgb-split-effect 0.3s infinite linear; }
      .effect-reflection::after { content: ''; position: absolute; top: 100%; left: 0; right: 0; height: 50%; background: inherit; transform: scaleY(-1); opacity: 0.5; mask-image: linear-gradient(to bottom, white, transparent); }
      .effect-liquid-metal { filter: url(#liquid-metal-filter); background: #ccc; }
      .effect-ascii { font-family: monospace; color: #0f0; letter-spacing: 2px; line-height: 0.8; word-wrap: break-word; text-align: center; background: #000; font-size: 5px; }
      .effect-blueprint { filter: brightness(0) invert(1) sepia(1) hue-rotate(180deg) saturate(5) contrast(1.5); background-color: #00f; mix-blend-mode: screen; }
      .effect-broken-glass { mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><defs><pattern id="p" patternUnits="userSpaceOnUse" width="50" height="50"><path d="M0 50L50 0" stroke="black" stroke-width="2"/><path d="M0 0L50 50" stroke="black" stroke-width="2"/><path d="M25 0V50" stroke="black" stroke-width="1"/><path d="M0 25H50" stroke="black" stroke-width="1"/></pattern></defs><rect width="100" height="100" fill="url(%23p)"/></svg>'); }
      .effect-3d-flip-h { animation: flip-h-effect 3s infinite linear; }
      .effect-3d-flip-v { animation: flip-v-effect 3s infinite linear; }
      .effect-zoom-blur { animation: zoom-blur-effect 2s infinite ease-in-out; }
      .effect-radial-blur { filter: url(#radial-blur-filter); }
      .effect-color-cycle { animation: color-cycle-effect 2s infinite linear; }
      .effect-night-vision { filter: brightness(1.2) contrast(1.5) hue-rotate(90deg) saturate(3); }
      .effect-thermal { filter: contrast(1.5) sepia(1) hue-rotate(-60deg) saturate(2); }
      .effect-matrix-rain::after { content: '01'; position: absolute; inset: 0; font-family: monospace; color: #0f0; writing-mode: vertical-rl; text-orientation: upright; animation: matrix-rain-effect 0.1s infinite linear; font-size: 10px; overflow: hidden; opacity: 0.3; }
      .effect-polygon-mask { clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%); }
      .effect-star-mask { clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); }
      .effect-burn { filter: contrast(1.5) saturate(2) hue-rotate(-20deg) brightness(0.9); }
      .effect-frozen { filter: brightness(1.1) contrast(1.2) saturate(0) sepia(0.3) hue-rotate(180deg); }
      .effect-dreamy { filter: blur(2px) saturate(1.5) contrast(1.1) brightness(1.1); }
      .effect-ghostly { filter: blur(1px) contrast(1.5) brightness(1.5); opacity: 0.8; }
      
      /* --- VISUAL EFFECTS KEYFRAMES --- */
      @keyframes wobble-effect { 0%, 100% { transform: rotate(0) scale(1); } 25% { transform: rotate(2deg) scale(1.02); } 75% { transform: rotate(-2deg) scale(0.98); } }
      @keyframes flicker-effect { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
      @keyframes tv-static-effect { 0% { background-position: 0 0; } 100% { background-position: 100% 100%; } }
      @keyframes vcr-glitch-effect { 0%, 100% { clip-path: inset(0); } 10% { clip-path: inset(10% 0 85% 0); transform: translateX(-5px); } 40% { clip-path: inset(50% 0 40% 0); transform: translateX(5px); } 80% { clip-path: inset(90% 0 5% 0); } }
      @keyframes film-grain-effect { 0% { transform: translate(0,0); } 25% { transform: translate(-2px, 2px); } 50% { transform: translate(2px, -2px); } 75% { transform: translate(-2px, -2px); } }
      @keyframes tunnel-effect { 0% { transform: scale(1) rotate(0); } 100% { transform: scale(5) rotate(360deg); } }
      @keyframes slit-scan-effect { 0%, 100% { background-position: 0 0; } 50% { background-position: 0 100%; } }
      @keyframes rgb-split-effect { 0%, 100% { text-shadow: 0 0 red, 0 0 blue; } 50% { text-shadow: -2px 0 red, 2px 0 blue; } }
      @keyframes flip-h-effect { from { transform: perspective(500px) rotateY(0deg); } to { transform: perspective(500px) rotateY(360deg); } }
      @keyframes flip-v-effect { from { transform: perspective(500px) rotateX(0deg); } to { transform: perspective(500px) rotateX(360deg); } }
      @keyframes zoom-blur-effect { 0%, 100% { filter: blur(0); transform: scale(1); } 50% { filter: blur(5px); transform: scale(1.1); } }
      @keyframes color-cycle-effect { 0% { filter: hue-rotate(0deg); } 100% { filter: hue-rotate(360deg); } }
      @keyframes matrix-rain-effect { to { transform: translateY(100%); } }
      
      /* Privacy & License Notice Styles */
      .privacy-notice {
        border-left: 3px solid #3b82f6;
        background: linear-gradient(90deg, rgba(59, 130, 246, 0.1) 0%, transparent 100%);
      }
      .license-warning {
        border-left: 3px solid #ef4444;
        background: linear-gradient(90deg, rgba(239, 68, 68, 0.1) 0%, transparent 100%);
      }
      .copyright-notice {
        font-size: 10px;
        background: rgba(0, 0, 0, 0.3);
      }
      
      /* Responsive Design Improvements */
      @media (max-width: 768px) {
        /* Mobile-specific touch improvements */
        .touch-friendlier {
          min-height: 44px;
          min-width: 44px;
        }
        
        /* Better spacing on mobile */
        .mobile-padding {
          padding: 0.75rem;
        }
        
        /* Adjust sidebar width for mobile */
        .mobile-sidebar {
          width: 100%;
          max-width: 100vw;
        }
        
        /* Larger touch targets */
        .touch-target {
          padding: 12px;
        }
        
        /* Adjust canvas area for mobile */
        .mobile-canvas {
          height: calc(100dvh - 60px);
        }
      }
      
      /* Tablet optimizations */
      @media (min-width: 769px) and (max-width: 1024px) {
        .tablet-sidebar {
          width: 320px;
        }
      }
      
      /* Scrollable startup modal */
      .startup-modal-content {
        max-height: 85vh;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      
      /* Prevent text selection on interactive elements */
      .no-select {
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }
      
      /* Improved touch scrolling */
      .touch-scroll {
        -webkit-overflow-scrolling: touch;
        scroll-behavior: smooth;
      }
    </style>

    <!-- React & Babel Standalone -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>
    
    <!-- SVG Filters for Effects -->
    <svg style="position:absolute; width:0; height:0; visibility:hidden;">
        <defs>
            <filter id="pixelate-filter"><feFlood x="4" y="4" height="2" width="2"/><feComposite width="10" height="10"/><feTile result="a"/><feComposite in="SourceGraphic" in2="a" operator="in"/><feMorphology operator="dilate" radius="5"/></filter>
            <filter id="heatwave-filter"><feTurbulence type="fractalNoise" baseFrequency="0.01 0.04" numOctaves="3" seed="2" result="turbulence"/><feDisplacementMap in="SourceGraphic" in2="turbulence" scale="10" xChannelSelector="R" yChannelSelector="G"/></filter>
            <filter id="edge-detect-filter"><feConvolveMatrix order="3,3" kernelMatrix="-1 -1 -1 -1 8 -1 -1 -1 -1" /></filter>
            <filter id="emboss-filter"><feConvolveMatrix order="3,3" kernelMatrix="-2 -1 0 -1 1 1 0 1 2" /></filter>
            <filter id="sharpen-filter"><feConvolveMatrix order="3,3" kernelMatrix="0 -1 0 -1 5 -1 0 -1 0" /></filter>
            <filter id="liquid-metal-filter"><feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur" /><feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 18 -7" result="contrast" /><feBlend in="SourceGraphic" in2="contrast" /></filter>
            <filter id="radial-blur-filter">
                <feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blurred" />
                <feBlend in="SourceGraphic" in2="blurred" mode="multiply" />
            </filter>
        </defs>
    </svg>

    <!-- MAIN APPLICATION SCRIPT -->
    <script type="text/babel" data-presets="typescript,react">
        const { useState, useRef, useEffect, useCallback, useMemo } = React;
        
        // --- HELPERS & CONSTANTS ---
        function uuidv4() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => { var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }
        const SurfaceType = { IMAGE: 'IMAGE', VIDEO: 'VIDEO', COLOR: 'COLOR', LINE: 'LINE', TEXT: 'TEXT' };
        
        const VISUAL_EFFECTS = [
          {id:'none', name:'Kein Effekt', class:''}, {id:'invert', name:'Invertieren', class:'effect-invert'}, {id:'blur', name:'Unschärfe', class:'effect-blur'}, {id:'sepia', name:'Sepia', class:'effect-sepia'}, {id:'saturate', name:'Sättigung', class:'effect-saturate'}, {id:'grayscale', name:'Graustufen', class:'effect-grayscale'}, {id:'contrast', name:'Kontrast', class:'effect-contrast'}, {id:'brightness', name:'Helligkeit', class:'effect-brightness'}, {id:'hue-shift', name:'Farbton-Shift', class:'effect-hue-shift'}, {id:'neon-shadow', name:'Neon-Schatten', class:'effect-neon-shadow'}, {id:'skew', name:'Verzerren', class:'effect-skew'}, {id:'3d-xtilt', name:'3D Neigung X', class:'effect-3d-xtilt'}, {id:'3d-ytilt', name:'3D Neigung Y', class:'effect-3d-ytilt'}, {id:'wobble', name:'Wackeln', class:'effect-wobble'}, {id:'flicker', name:'Flackern', class:'effect-flicker'}, {id:'tv-static', name:'TV-Rauschen', class:'effect-tv-static'}, {id:'chromatic-aberration', name:'Chrom. Aberration', class:'effect-chromatic-aberration'}, {id:'pixelate', name:'Verpixeln', class:'effect-pixelate'}, {id:'spotlight', name:'Spotlight', class:'effect-spotlight'}, {id:'vcr-glitch', name:'VCR-Glitch', class:'effect-vcr-glitch'}, {id:'heatwave', name:'Hitzewelle', class:'effect-heatwave'}, {id:'film-grain', name:'Filmkorn', class:'effect-film-grain'}, {id:'tunnel-vision', name:'Tunnelblick', class:'effect-tunnel-vision'}, {id:'page-curl', name:'Eselsohr', class:'effect-page-curl'}, {id:'kaleidoscope', name:'Kaleidoskop', class:'effect-kaleidoscope'}, {id:'edge-detect', name:'Kantenerkennung', class:'effect-edge-detect'}, {id:'emboss', name:'Prägung', class:'effect-emboss'}, {id:'sharpen', name:'Schärfen', class:'effect-sharpen'}, {id:'slit-scan', name:'Slit-Scan', class:'effect-slit-scan'}, {id:'rgb-split', name:'RGB-Split', class:'effect-rgb-split'}, {id:'reflection', name:'Spiegelung', class:'effect-reflection'}, {id:'liquid-metal', name:'Flüssigmetall', class:'effect-liquid-metal'}, {id:'blueprint', name:'Blaupause', class:'effect-blueprint'}, {id:'broken-glass', name:'Glasbruch', class:'effect-broken-glass'}, {id:'3d-flip-h', name:'3D Flip H', class:'effect-3d-flip-h'}, {id:'3d-flip-v', name:'3D Flip V', class:'effect-3d-flip-v'}, {id:'zoom-blur', name:'Zoom-Unschärfe', class:'effect-zoom-blur'}, {id:'radial-blur', name:'Radial-Unschärfe', class:'effect-radial-blur'}, {id:'color-cycle', name:'Farbzyklus', class:'effect-color-cycle'}, {id:'night-vision', name:'Nachtsicht', class:'effect-night-vision'}, {id:'thermal', name:'Thermal', class:'effect-thermal'}, {id:'matrix-rain', name:'Matrix-Regen', class:'effect-matrix-rain'}, {id:'polygon-mask', name:'Polygon-Maske', class:'effect-polygon-mask'}, {id:'star-mask', name:'Stern-Maske', class:'effect-star-mask'}, {id:'burn', name:'Verbrennen', class:'effect-burn'}, {id:'frozen', name:'Gefroren', class:'effect-frozen'}, {id:'dreamy', name:'Träumerisch', class:'effect-dreamy'}, {id:'ghostly', name:'Geisterhaft', class:'effect-ghostly'}
        ];

        // --- NEW: PRIVACY & LICENSE COMPONENTS ---
        const PrivacyDisclaimer = () => (
          <div className="privacy-notice p-3 rounded mb-4">
            <div className="flex items-center gap-2 mb-1">
              <i className="fa-solid fa-shield-halved text-blue-400"></i>
              <strong className="text-blue-300 text-sm">Datenschutz</strong>
            </div>
            <p className="text-xs text-zinc-400">
              Alle Daten bleiben lokal auf Ihrem Gerät. Keine Server-Kommunikation. 
              Hochgeladene Medien werden nicht übertragen.
            </p>
          </div>
        );

        const LicenseWarning = () => (
          <div className="license-warning p-3 rounded mb-4">
            <div className="flex items-center gap-2 mb-1">
              <i className="fa-solid fa-scale-balanced text-red-400"></i>
              <strong className="text-red-300 text-sm">Lizenzbedingungen</strong>
            </div>
            <p className="text-xs text-zinc-400">
              Dieses Tool steht unter einer{' '}
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" 
                 target="_blank" 
                 rel="noopener noreferrer nofollow"
                 className="text-red-400 hover:underline font-semibold">
                CC BY-NC-SA 4.0 Lizenz
              </a>.
              <br/>
              <span className="text-red-300 font-semibold">Nur nicht-kommerzielle Nutzung erlaubt.</span>
            </p>
          </div>
        );

        const MediaUploadDisclaimer = ({ className = "" }) => (
          <div className={`bg-zinc-900/50 border border-zinc-700 rounded p-3 ${className}`}>
            <div className="flex items-center gap-2 mb-2">
              <i className="fa-solid fa-copyright text-amber-400"></i>
              <strong className="text-amber-300 text-sm">Urheberrechtshinweis</strong>
            </div>
            <p className="text-xs text-zinc-400">
              Bitte verwenden Sie nur selbst erstellte oder lizenzfreie Medien.
              Sie sind selbst verantwortlich für die Rechte aller hochgeladenen Inhalte.
            </p>
          </div>
        );

        const StartupInfoModal = ({ onClose }) => (
          <div className="fixed inset-0 bg-black/90 z-[1000] flex items-center justify-center p-4 touch-scroll">
            <div className="w-full max-w-lg bg-zinc-900 border border-zinc-700 rounded-xl p-6 shadow-2xl startup-modal-content">
              <div className="flex justify-between items-center mb-6">
                <h2 className="text-2xl font-bold bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">
                  Willkommen beim Projection Mapping Tool
                </h2>
                <button onClick={onClose} className="p-2 text-zinc-400 hover:text-white touch-friendlier">
                  <i className="fa-solid fa-xmark text-xl"></i>
                </button>
              </div>
              
              <div className="space-y-4 mb-6">
                <div className="p-4 bg-blue-900/20 border border-blue-800/50 rounded-lg">
                  <h3 className="font-bold text-blue-300 mb-2 flex items-center gap-2">
                    <i className="fa-solid fa-shield-halved"></i>
                    Datenschutz-Garantie
                  </h3>
                  <p className="text-sm text-zinc-300">
                    • Alle Daten bleiben 100% lokal auf Ihrem Gerät<br/>
                    • Keine Tracking-Cookies oder Analytics<br/>
                    • Keine Server-Kommunikation
                  </p>
                </div>
                
                <div className="p-4 bg-red-900/20 border border-red-800/50 rounded-lg">
                  <h3 className="font-bold text-red-300 mb-2 flex items-center gap-2">
                    <i className="fa-solid fa-scale-balanced"></i>
                    Lizenzbedingungen (CC BY-NC-SA 4.0)
                  </h3>
                  <p className="text-sm text-zinc-300">
                    • <strong>Nur nicht-kommerzielle Nutzung</strong> erlaubt<br/>
                    • Keine gewerbliche Verwendung<br/>
                    • Weitergabe unter gleichen Bedingungen<br/>
                    • Namensnennung erforderlich
                  </p>
                  <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" 
                     target="_blank" 
                     rel="noopener noreferrer nofollow"
                     className="inline-block mt-2 text-red-400 hover:underline text-sm">
                    <i className="fa-solid fa-external-link mr-1"></i>
                    Vollständige Lizenz lesen
                  </a>
                </div>
                
                <div className="p-4 bg-amber-900/20 border border-amber-800/50 rounded-lg">
                  <h3 className="font-bold text-amber-300 mb-2 flex items-center gap-2">
                    <i className="fa-solid fa-copyright"></i>
                    Urheberrechtshinweis
                  </h3>
                  <p className="text-sm text-zinc-300">
                    • Verwenden Sie nur eigene oder lizenzfreie Medien<br/>
                    • Sie tragen die Verantwortung für hochgeladene Inhalte<br/>
                    • Keine Haftung für Rechtsverstöße
                  </p>
                </div>
                
                <div className="p-4 bg-purple-900/20 border border-purple-800/50 rounded-lg">
                  <h3 className="font-bold text-purple-300 mb-2 flex items-center gap-2">
                    <i className="fa-solid fa-mobile-screen-button"></i>
                    Geräteoptimierung
                  </h3>
                  <p className="text-sm text-zinc-300">
                    • Vollständig optimiert für PC, Laptop, Tablet & Handy<br/>
                    • Touch-freundliche Bedienung<br/>
                    • Automatische Anpassung an Bildschirmgröße<br/>
                    • Volle Unterstützung für Hochformat und Querformat
                  </p>
                </div>
              </div>
              
              <div className="flex flex-col sm:flex-row gap-3">
                <button 
                  onClick={onClose} 
                  className="flex-1 py-3 bg-gradient-to-r from-blue-600 to-purple-600 rounded-lg text-white font-bold shadow-lg hover:brightness-110 transition-all touch-target no-select"
                >
                  Tool starten
                </button>
              </div>
              
              <div className="mt-6 pt-4 border-t border-zinc-800 text-xs text-zinc-500">
                <p>Verwendete Bibliotheken: React (MIT), Tailwind CSS (MIT), FontAwesome (CC BY 4.0), Babel (MIT)</p>
              </div>
            </div>
          </div>
        );

        // --- UTILS: MATRIX & MATH ---
        function solve(A, b) { const n = A.length; for (let i = 0; i < n; i++) { let maxEl = Math.abs(A[i][i]); let maxRow = i; for (let k = i + 1; k < n; k++) if (Math.abs(A[k][i]) > maxEl) { maxEl = Math.abs(A[k][i]); maxRow = k; } for (let k = i; k < n; k++) { const tmp = A[maxRow][k]; A[maxRow][k] = A[i][k]; A[i][k] = tmp; } const tmp = b[maxRow]; b[maxRow] = b[i]; b[i] = tmp; for (let k = i + 1; k < n; k++) { const c = -A[k][i] / A[i][i]; for (let j = i; j < n; j++) { if (i === j) A[k][j] = 0; else A[k][j] += c * A[i][j]; } b[k] += c * b[i]; } } const x = new Array(n).fill(0); for (let i = n - 1; i > -1; i--) { let sum = 0; for (let j = i + 1; j < n; j++) sum += A[i][j] * x[j]; x[i] = (b[i] - sum) / A[i][i]; } return x; }
        function getPerspectiveTransform(width, height, corners) { const [p0, p1, p2, p3] = corners; const A = []; const b = []; const srcPts = [{x: 0, y: 0}, {x: width, y: 0}, {x: width, y: height}, {x: 0, y: height}]; for(let i=0; i<4; i++) { const s = srcPts[i]; const d = corners[i]; A.push([s.x, s.y, 1, 0, 0, 0, -s.x*d.x, -s.y*d.x]); b.push(d.x); A.push([0, 0, 0, s.x, s.y, 1, -s.x*d.y, -s.y*d.y]); b.push(d.y); } const X = solve(A, b); const rounded = X.map(val => Math.abs(val) < 1e-6 ? 0 : val); return `matrix3d(${rounded[0]}, ${rounded[3]}, 0, ${rounded[6]}, ${rounded[1]}, ${rounded[4]}, 0, ${rounded[7]}, 0, 0, 1, 0, ${rounded[2]}, ${rounded[5]}, 0, 1)`; }
        function getPolygonPerimeter(points) { if (!points || points.length < 2) return 0; let len = 0; for(let i=0; i<points.length; i++) { const p1 = points[i]; const p2 = points[(i+1)%points.length]; const dx = p1.x - p2.x; const dy = p1.y - p2.y; len += Math.sqrt(dx*dx + dy*dy); } return len; }
        function getInterpolatedZoom(surface, localProgress) { const keyframes = surface.keyframes; if (!keyframes || keyframes.length === 0) return 1; const progress = Math.max(0, Math.min(1, localProgress)); const sortedKeyframes = [...keyframes].sort((a, b) => a.time - b.time); if (progress <= sortedKeyframes[0].time) return sortedKeyframes[0].zoom; if (progress >= sortedKeyframes[sortedKeyframes.length - 1].time) return sortedKeyframes[sortedKeyframes.length - 1].zoom; let prevKeyframe = sortedKeyframes[0]; let nextKeyframe = sortedKeyframes[sortedKeyframes.length - 1]; for (let i = 0; i < sortedKeyframes.length; i++) { if (sortedKeyframes[i].time <= progress) prevKeyframe = sortedKeyframes[i]; if (sortedKeyframes[i].time > progress) { nextKeyframe = sortedKeyframes[i]; break; } } if (prevKeyframe === nextKeyframe || prevKeyframe.time === nextKeyframe.time) return prevKeyframe.zoom; const timeDiff = nextKeyframe.time - prevKeyframe.time; const progressInSegment = (progress - prevKeyframe.time) / timeDiff; const zoomDiff = nextKeyframe.zoom - prevKeyframe.zoom; return prevKeyframe.zoom + (zoomDiff * progressInSegment); }

        // --- COMPONENTS ---
        const DrawingModal = ({ onClose, onSave }) => { 
          const [showMediaDisclaimer, setShowMediaDisclaimer] = useState(true);
          const canvasRef = useRef(null); const [isDrawing, setIsDrawing] = useState(false); const [ctx, setCtx] = useState(null); const [color, setColor] = useState('#00ffff'); const [lineWidth, setLineWidth] = useState(5); const [drawMode, setDrawMode] = useState('free'); const [startPos, setStartPos] = useState(null); const [snapshot, setSnapshot] = useState(null); const CANVAS_SIZE = 500; useEffect(() => { const canvas = canvasRef.current; if (canvas) { canvas.width = CANVAS_SIZE; canvas.height = CANVAS_SIZE; const context = canvas.getContext('2d', { willReadFrequently: true }); context.lineCap = 'round'; context.lineJoin = 'round'; setCtx(context); } }, []); useEffect(() => { if(ctx) { ctx.strokeStyle = color; ctx.lineWidth = lineWidth; } }, [ctx, color, lineWidth]); const getPos = (e) => { const rect = canvasRef.current.getBoundingClientRect(); const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; return { x: (clientX - rect.left) * (canvasRef.current.width / rect.width), y: (clientY - rect.top) * (canvasRef.current.height / rect.height) }; }; const startDraw = (e) => { if(!ctx) return; e.preventDefault(); setIsDrawing(true); const pos = getPos(e); setStartPos(pos); setSnapshot(ctx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE)); ctx.beginPath(); ctx.moveTo(pos.x, pos.y); }; const draw = (e) => { if(!isDrawing || !ctx) return; e.preventDefault(); const pos = getPos(e); if (drawMode !== 'free') { ctx.putImageData(snapshot, 0, 0); ctx.beginPath(); const dx = pos.x - startPos.x; const dy = pos.y - startPos.y; if (drawMode === 'line') { ctx.moveTo(startPos.x, startPos.y); ctx.lineTo(pos.x, pos.y); } else if (drawMode === 'circle') { const radius = Math.sqrt(dx*dx + dy*dy); ctx.arc(startPos.x, startPos.y, radius, 0, Math.PI * 2); } else if (drawMode === 'semicircle') { const radius = Math.sqrt(dx*dx + dy*dy) / 2; const centerX = (startPos.x + pos.x) / 2; const centerY = (startPos.y + pos.y) / 2; const angle = Math.atan2(dy, dx); ctx.arc(centerX, centerY, radius, angle, angle + Math.PI); } else if (drawMode === 'arc') { const radius = Math.sqrt(dx*dx + dy*dy); const angle = Math.atan2(dy, dx); ctx.arc(startPos.x, startPos.y, radius, 0, angle); } else if (drawMode === 'curve') { ctx.moveTo(startPos.x, startPos.y); ctx.quadraticCurveTo(startPos.x, pos.y, pos.x, pos.y); } ctx.stroke(); } else { ctx.lineTo(pos.x, pos.y); ctx.stroke(); } }; const stopDraw = () => { setIsDrawing(false); if(ctx) ctx.closePath(); }; 
          return (
            <div className="absolute inset-0 bg-black/90 z-[300] flex items-center justify-center p-4 touch-scroll">
              <div className="bg-zinc-900 border border-zinc-700 rounded-lg p-4 shadow-xl flex flex-col max-w-lg w-full">
                <div className="flex justify-between items-center mb-4 text-white">
                  <h3 className="text-lg font-bold">Fenster Zeichnen</h3>
                  <div className="flex gap-1">
                    <button onClick={()=>setDrawMode('free')} className={`p-2 rounded ${drawMode==='free'?'bg-blue-600':'bg-zinc-800'} touch-friendlier`} title="Freihand"><i className="fa-solid fa-pen"></i></button>
                    <button onClick={()=>setDrawMode('line')} className={`p-2 rounded ${drawMode==='line'?'bg-blue-600':'bg-zinc-800'} touch-friendlier`} title="Linie"><i className="fa-solid fa-minus"></i></button>
                    <button onClick={()=>setDrawMode('circle')} className={`p-2 rounded ${drawMode==='circle'?'bg-blue-600':'bg-zinc-800'} touch-friendlier`} title="Kreis"><i className="fa-regular fa-circle"></i></button>
                    <button onClick={()=>setDrawMode('semicircle')} className={`p-2 rounded ${drawMode==='semicircle'?'bg-blue-600':'bg-zinc-800'} touch-friendlier`} title="Halbkreis"><i className="fa-solid fa-circle-half-stroke"></i></button>
                    <button onClick={()=>setDrawMode('arc')} className={`p-2 rounded ${drawMode==='arc'?'bg-blue-600':'bg-zinc-800'} touch-friendlier`} title="Bogen"><i className="fa-solid fa-bezier-curve"></i></button>
                    <button onClick={()=>setDrawMode('curve')} className={`p-2 rounded ${drawMode==='curve'?'bg-blue-600':'bg-zinc-800'} touch-friendlier`} title="Kurve"><i className="fa-solid fa-wave-square"></i></button>
                    <button onClick={onClose} className="p-2 text-zinc-400 hover:text-white touch-friendlier"><i className="fa-solid fa-xmark"></i></button>
                  </div>
                </div>
                
                {showMediaDisclaimer && (
                  <MediaUploadDisclaimer className="mb-4" />
                )}
                
                <div className="relative w-full aspect-square bg-zinc-950 border border-zinc-800 rounded mb-4 overflow-hidden">
                  <canvas ref={canvasRef} className="w-full h-full touch-none cursor-crosshair" 
                    onMouseDown={startDraw} onMouseMove={draw} onMouseUp={stopDraw} onMouseLeave={stopDraw}
                    onTouchStart={startDraw} onTouchMove={draw} onTouchEnd={stopDraw}/>
                </div>
                
                <div className="flex gap-4 mb-4 items-center">
                  <input type="color" value={color} onChange={(e) => setColor(e.target.value)} className="w-10 h-10 rounded cursor-pointer bg-transparent border-none touch-friendlier"/>
                  <div className="flex-1">
                    <label className="text-[10px] text-zinc-500 uppercase">Pinselgröße</label>
                    <input type="range" min="1" max="20" value={lineWidth} onChange={(e) => setLineWidth(parseInt(e.target.value))} className="w-full accent-blue-500 h-2 bg-zinc-800 rounded-lg touch-friendlier"/>
                  </div>
                  <button onClick={() => ctx?.clearRect(0,0,CANVAS_SIZE,CANVAS_SIZE)} className="w-10 h-10 rounded bg-zinc-800 text-zinc-400 hover:text-white border border-zinc-700 touch-friendlier">
                    <i className="fa-solid fa-trash"></i>
                  </button>
                </div>
                
                <button onClick={() => onSave(canvasRef.current.toDataURL())} className="w-full py-3 bg-gradient-to-r from-cyan-500 to-blue-600 rounded text-white font-bold shadow-lg uppercase touch-target no-select">
                  Als Ebene hinzufügen
                </button>
              </div>
            </div>
          ); 
        };
        
        const ScreenDrawingOverlay = ({ onClose, onSave }) => { 
          const canvasRef = useRef(null); const [isDrawing, setIsDrawing] = useState(false); const [ctx, setCtx] = useState(null); const [color, setColor] = useState('#00ff00'); const [lineWidth, setLineWidth] = useState(8); const [drawMode, setDrawMode] = useState('free'); const [startPos, setStartPos] = useState(null); const [snapshot, setSnapshot] = useState(null); useEffect(() => { const canvas = canvasRef.current; if (canvas) { canvas.width = window.innerWidth; canvas.height = window.innerHeight; const context = canvas.getContext('2d', { willReadFrequently: true }); context.lineCap = 'round'; context.lineJoin = 'round'; setCtx(context); } }, []); useEffect(() => { if(ctx) { ctx.strokeStyle = color; ctx.lineWidth = lineWidth; } }, [ctx, color, lineWidth]); const getPos = (e) => ({ x: e.touches ? e.touches[0].clientX : e.clientX, y: e.touches ? e.touches[0].clientY : e.clientY }); const startDraw = (e) => { if(!ctx) return; setIsDrawing(true); const pos = getPos(e); setStartPos(pos); setSnapshot(ctx.getImageData(0, 0, canvasRef.current.width, canvasRef.current.height)); ctx.beginPath(); ctx.moveTo(pos.x, pos.y); }; const draw = (e) => { if(!isDrawing || !ctx) return; e.preventDefault(); const pos = getPos(e); if (drawMode !== 'free') { ctx.putImageData(snapshot, 0, 0); ctx.beginPath(); const dx = pos.x - startPos.x; const dy = pos.y - startPos.y; if (drawMode === 'line') { ctx.moveTo(startPos.x, startPos.y); ctx.lineTo(pos.x, pos.y); } else if (drawMode === 'circle') { const radius = Math.sqrt(dx*dx + dy*dy); ctx.arc(startPos.x, startPos.y, radius, 0, Math.PI * 2); } else if (drawMode === 'semicircle') { const radius = Math.sqrt(dx*dx + dy*dy) / 2; const centerX = (startPos.x + pos.x) / 2; const centerY = (startPos.y + pos.y) / 2; const angle = Math.atan2(dy, dx); ctx.arc(centerX, centerY, radius, angle, angle + Math.PI); } else if (drawMode === 'arc') { const radius = Math.sqrt(dx*dx + dy*dy); const angle = Math.atan2(dy, dx); ctx.arc(startPos.x, startPos.y, radius, 0, angle); } else if (drawMode === 'curve') { ctx.moveTo(startPos.x, startPos.y); ctx.quadraticCurveTo(startPos.x, pos.y, pos.x, pos.y); } ctx.stroke(); } else { ctx.lineTo(pos.x, pos.y); ctx.stroke(); } }; const handleSave = () => { if (!canvasRef.current) return; const w = canvasRef.current.width, h = canvasRef.current.height, ctx2d = canvasRef.current.getContext('2d'), imgData = ctx2d.getImageData(0, 0, w, h), { data } = imgData; let minX = w, minY = h, maxX = 0, maxY = 0, found = false; for (let i = 0; i < data.length; i += 4) { if (data[i + 3] > 0) { const idx = i / 4, x = idx % w, y = Math.floor(idx / w); if (x < minX) minX = x; if (x > maxX) maxX = x; if (y < minY) minY = y; if (y > maxY) maxY = y; found = true; } } if (!found) { onClose(); return; } const cropWidth = maxX - minX + 10, cropHeight = maxY - minY + 10; const tempCanvas = document.createElement('canvas'); tempCanvas.width = cropWidth; tempCanvas.height = cropHeight; const tCtx = tempCanvas.getContext('2d'), srcX = Math.max(0, minX - 5), srcY = Math.max(0, minY - 5); tCtx.drawImage(canvasRef.current, srcX, srcY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight); onSave(tempCanvas.toDataURL('image/png'), { x: srcX, y: srcY, w: cropWidth, h: cropHeight }); }; 
          return (
            <div className="fixed inset-0 z-[500] cursor-crosshair">
              <canvas ref={canvasRef} className="w-full h-full touch-none" style={{ background: 'rgba(0,0,0,0.3)' }} 
                onMouseDown={startDraw} onMouseMove={draw} onMouseUp={()=>setIsDrawing(false)}
                onTouchStart={startDraw} onTouchMove={draw} onTouchEnd={()=>setIsPlaying(false)}/>
              
              <div className="absolute top-4 left-1/2 transform -translate-x-1/2 flex items-center gap-2 bg-zinc-900/95 p-2 px-4 rounded-full border border-zinc-700 shadow-2xl">
                <div className="flex gap-1">
                  <button onClick={()=>setDrawMode('free')} className={`w-10 h-10 rounded-full flex items-center justify-center transition-colors ${drawMode==='free'?'bg-blue-600 text-white':'bg-zinc-800 text-zinc-400'} touch-friendlier`} title="Freihand"><i className="fa-solid fa-pen"></i></button>
                  <button onClick={()=>setDrawMode('line')} className={`w-10 h-10 rounded-full flex items-center justify-center transition-colors ${drawMode==='line'?'bg-blue-600 text-white':'bg-zinc-800 text-zinc-400'} touch-friendlier`} title="Linie"><i className="fa-solid fa-minus"></i></button>
                  <button onClick={()=>setDrawMode('circle')} className={`w-10 h-10 rounded-full flex items-center justify-center transition-colors ${drawMode==='circle'?'bg-blue-600 text-white':'bg-zinc-800 text-zinc-400'} touch-friendlier`} title="Kreis"><i className="fa-regular fa-circle"></i></button>
                  <button onClick={()=>setDrawMode('semicircle')} className={`w-10 h-10 rounded-full flex items-center justify-center transition-colors ${drawMode==='semicircle'?'bg-blue-600 text-white':'bg-zinc-800 text-zinc-400'} touch-friendlier`} title="Halbkreis"><i className="fa-solid fa-circle-half-stroke"></i></button>
                  <button onClick={()=>setDrawMode('arc')} className={`w-10 h-10 rounded-full flex items-center justify-center transition-colors ${drawMode==='arc'?'bg-blue-600 text-white':'bg-zinc-800 text-zinc-400'} touch-friendlier`} title="Bogen"><i className="fa-solid fa-bezier-curve"></i></button>
                  <button onClick={()=>setDrawMode('curve')} className={`w-10 h-10 rounded-full flex items-center justify-center transition-colors ${drawMode==='curve'?'bg-blue-600 text-white':'bg-zinc-800 text-zinc-400'} touch-friendlier`} title="Kurve"><i className="fa-solid fa-wave-square"></i></button>
                </div>
                <div className="w-[1px] h-6 bg-zinc-800 mx-1"></div>
                <input type="color" value={color} onChange={(e) => setColor(e.target.value)} className="w-8 h-8 rounded-full border-none cursor-pointer bg-transparent touch-friendlier"/>
                <input type="range" min="1" max="30" value={lineWidth} onChange={(e) => setLineWidth(parseInt(e.target.value))} className="w-24 accent-blue-500 touch-friendlier"/>
                <button onClick={handleSave} className="px-4 py-1.5 bg-green-600 hover:bg-green-500 rounded-full text-white text-[10px] font-bold uppercase transition-all shadow-lg shadow-green-900/20 touch-target no-select">Fertig</button>
                <button onClick={onClose} className="px-4 py-1.5 bg-red-600 hover:bg-red-500 rounded-full text-white text-[10px] font-bold uppercase transition-all touch-target no-select">Abbruch</button>
              </div>
              
              {/* Media Upload Disclaimer */}
              <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 max-w-md">
                <MediaUploadDisclaimer />
              </div>
            </div>
          ); 
        };
        
        const EffectsLibraryModal = ({ onClose, onSelect }) => { 
          const [search, setSearch] = useState(''); 
          const filtered = VISUAL_EFFECTS.filter(e => e.name.toLowerCase().includes(search.toLowerCase())); 
          return (
            <div className="absolute inset-0 bg-black/90 z-[300] flex items-center justify-center p-4">
              <div className="bg-zinc-900 border border-zinc-700 rounded-lg p-4 shadow-xl flex flex-col max-w-2xl w-full h-[80vh]">
                <div className="flex justify-between items-center mb-4">
                  <h3 className="text-lg font-bold text-white">Effekt-Bibliothek</h3>
                  <button onClick={onClose} className="p-2 text-zinc-400 hover:text-white touch-friendlier">
                    <i className="fa-solid fa-xmark"></i>
                  </button>
                </div>
                
                <input type="text" placeholder="Suchen..." value={search} onChange={e=>setSearch(e.target.value)} 
                  className="w-full bg-zinc-800 border border-zinc-700 rounded px-3 py-2 text-sm text-white mb-4 outline-none focus:border-blue-500"/>
                
                <div className="flex-1 overflow-y-auto touch-scroll grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3 pr-2">
                  {filtered.map(effect => (
                    <div key={effect.id} onClick={() => onSelect(effect.id)} 
                      className="flex flex-col items-center p-2 rounded bg-zinc-800 hover:bg-blue-900/30 cursor-pointer border border-zinc-700 aspect-square justify-center touch-target no-select">
                      <div className={`effect-preview w-16 h-16 mb-2 rounded ${effect.class}`}></div>
                      <div className="text-xs text-center text-zinc-300">{effect.name}</div>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          ); 
        };

        const SurfaceLayer = ({ surface, isSelected, onSelect, isPlaying = false, globalTime = 0 }) => {
          const INTERNAL_WIDTH = 1000; const INTERNAL_HEIGHT = 1000; const videoRef = useRef(null);
          const safeStart = Number(surface.timelineStart) || 0; const safeDuration = Number(surface.timelineDuration) || 10; const playbackRate = Number(surface.playbackRate) || 1.0;
          const isActive = useMemo(() => { if (!isPlaying) return surface.visible; const end = safeStart + safeDuration; return globalTime >= safeStart && globalTime < end; }, [isPlaying, globalTime, surface.visible, safeStart, safeDuration]);
          const currentZoom = useMemo(() => { if (surface.type !== SurfaceType.VIDEO) return 1; const localProgress = safeDuration > 0 ? (globalTime - safeStart) / safeDuration : 0; return getInterpolatedZoom(surface, localProgress); }, [surface, globalTime, safeStart, safeDuration, isPlaying]);
          const transformStyle = useMemo(() => getPerspectiveTransform(INTERNAL_WIDTH, INTERNAL_HEIGHT, surface.corners), [surface.corners]);
          const maskClipPath = useMemo(() => { if (!surface.maskPoints || surface.maskPoints.length < 3) return undefined; return `polygon(${surface.maskPoints.map(p => `${p.x}px ${p.y}px`).join(',')})`; }, [surface.maskPoints]);
          useEffect(() => { if (surface.type === SurfaceType.VIDEO && videoRef.current) { const vid = videoRef.current; vid.volume = surface.volume ?? 1.0; vid.muted = surface.isMuted ?? false; if (vid.playbackRate !== playbackRate) vid.playbackRate = playbackRate; if(vid.loop !== (surface.loopMode !== 'once')) vid.loop = (surface.loopMode !== 'once'); if (isPlaying) { if (isActive) { const videoElapsedTimeline = globalTime - safeStart; const targetVideoTime = (videoElapsedTimeline * playbackRate); if (Number.isFinite(vid.duration) && vid.duration > 0) { const modTarget = targetVideoTime % vid.duration; const diff = Math.abs(vid.currentTime - modTarget); if (diff > 0.8 && !vid.seeking) vid.currentTime = modTarget; } if (vid.paused) vid.play().catch(e => {}); } else { if (!vid.paused) vid.pause(); vid.currentTime = 0; } } else { if (isActive) { if (vid.paused) vid.play().catch(()=>{}); } else vid.pause(); } } }, [isPlaying, isActive, globalTime, safeStart, surface.volume, surface.isMuted, surface.type, surface.loopMode, playbackRate]);
          const isLineAndMasked = (surface.type === SurfaceType.LINE && surface.maskPoints && surface.maskPoints.length >= 2);
          const shapeStyle = useMemo(() => { if (surface.maskPoints && surface.maskPoints.length >= 3 || surface.type === SurfaceType.LINE) return {}; switch (surface.shape) { case 'circle': return { borderRadius: '50%', overflow: 'hidden' }; case 'triangle': return { clipPath: 'polygon(50% 0%, 0% 100%, 100% 100%)', overflow: 'hidden' }; case 'rect': default: return { overflow: 'hidden' }; } }, [surface.shape, surface.type, surface.maskPoints]);
          const effectClass = useMemo(() => VISUAL_EFFECTS.find(e => e.id === surface.effect)?.class || '', [surface.effect]);
          
          const renderContent = () => { if (surface.type === SurfaceType.LINE && surface.maskPoints && surface.maskPoints.length > 0) return null; const isAnimated = surface.animationSpeed && surface.animationSpeed > 0; const animType = surface.animationType || 'simple'; let animClass = ''; if (isAnimated) { const mapping = { 'shake':'animate-shake', 'float':'animate-float', 'blink':'animate-blink', 'sway':'animate-sway', 'scale':'animate-scale', 'glitch':'animate-glitch', 'chase': surface.type === SurfaceType.LINE ? 'animate-dash' : (surface.type === SurfaceType.COLOR ? 'animate-scanner' : 'animate-image-chase'), 'draw': surface.type === SurfaceType.LINE ? 'animate-draw' : 'animate-image-draw', 'spin3d': 'animate-spin-3d', 'pulse': 'animate-text-pulse', 'flip': 'animate-text-flip', 'simple': surface.type === SurfaceType.TEXT ? 'animate-text-3d' : (surface.type === SurfaceType.IMAGE ? 'animate-hue' : 'animate-glow') }; animClass = mapping[animType] || mapping['simple']; } const animStyle = isAnimated ? { animationDuration: `${surface.animationSpeed}s` } : {}; switch(surface.type) { case SurfaceType.VIDEO: return <video ref={videoRef} src={surface.src} className="w-full h-full object-cover block" style={{ transform: `scale(${currentZoom})`}} playsInline webkit-playsinline="true" preload="auto" muted={surface.isMuted} />; case SurfaceType.IMAGE: return (<div className="w-full h-full relative"><img src={surface.src} alt={surface.name} className={`w-full h-full object-fill block ${animClass}`} style={animStyle} draggable={false}/></div>); case SurfaceType.TEXT: return (<div className="w-full h-full flex items-center justify-center pointer-events-none" style={{perspective:'1000px'}}><div className={`${animClass} leading-tight text-center`} style={{color:surface.src, fontSize:`${surface.fontSize||100}px`, fontWeight:'bold', writingMode:surface.isVertical?'vertical-rl':'horizontal-tb', textOrientation:'upright', ...animStyle}}>{surface.textContent||'TEXT'}</div></div>); case SurfaceType.LINE: const strokeWidth=(surface.lineWidth||10)*2; const inset=strokeWidth/2; const w=INTERNAL_WIDTH-strokeWidth; const h=INTERNAL_HEIGHT-strokeWidth; let dashArray=(isAnimated&&animType==='chase')?`${w/4} ${w/4}`:undefined; let svgTransform=undefined; if(isAnimated&&animType==='draw'){ let perimeter=4000; if(surface.shape==='rect')perimeter=2*(w+h); if(surface.shape==='circle')perimeter=Math.PI*w; if(surface.shape==='triangle')perimeter=w+2*Math.sqrt(Math.pow(w/2,2)+Math.pow(h,2)); dashArray=`${perimeter}`; animStyle.strokeDasharray=perimeter; animStyle.strokeDashoffset=perimeter; if(surface.shape==='rect'){svgTransform='rotate(-90deg)'; animStyle.transformOrigin='center';} if(surface.shape==='circle'){svgTransform='rotate(90deg)'; animStyle.transformOrigin='center';}} return (<svg width="100%" height="100%" viewBox={`0 0 ${INTERNAL_WIDTH} ${INTERNAL_HEIGHT}`} className={`overflow-visible ${animClass}`} style={{...animStyle,transform:svgTransform}}>{surface.shape==='rect'&&<rect x={inset} y={inset} width={w} height={h} fill="none" stroke={surface.src} strokeWidth={strokeWidth} strokeDasharray={dashArray}/>}{surface.shape==='circle'&&<circle cx={INTERNAL_WIDTH/2} cy={INTERNAL_HEIGHT/2} r={w/2} fill="none" stroke={surface.src} strokeWidth={strokeWidth} strokeDasharray={dashArray}/>}{surface.shape==='triangle'&&<polygon points={`${INTERNAL_WIDTH/2},${inset} ${INTERNAL_WIDTH-inset},${INTERNAL_HEIGHT-inset} ${inset},${INTERNAL_HEIGHT-inset}`} fill="none" stroke={surface.src} strokeWidth={strokeWidth} strokeDasharray={dashArray}/>}</svg>); case SurfaceType.COLOR: const colorStyle={backgroundColor:surface.src, ...animStyle}; if(isAnimated&&animType==='chase'){colorStyle.backgroundColor='transparent'; colorStyle.backgroundImage=`linear-gradient(110deg, ${surface.src} 20%, #ffffff 50%, ${surface.src} 80%)`;} return <div className={`w-full h-full ${animClass}`} style={colorStyle}/>; default: return <div className="w-full h-full" style={{backgroundColor:surface.src}}/>; } }
          if (!isActive) return null; const rotation = surface.rotation || 0; const isAnimated = surface.animationSpeed && surface.animationSpeed > 0; const animType = surface.animationType || 'simple'; let maskAnimClass = ''; const maskAnimStyle = isAnimated ? { animationDuration: `${surface.animationSpeed}s` } : {}; if (isLineAndMasked && isAnimated) { const perimeter = getPolygonPerimeter(surface.maskPoints); if (animType === 'chase') { maskAnimClass = 'animate-dash'; maskAnimStyle.strokeDasharray = `${perimeter/20} ${perimeter/20}`; } else if (animType === 'draw') { maskAnimClass = 'animate-draw'; maskAnimStyle.strokeDasharray = `${perimeter}`; maskAnimStyle.strokeDashoffset = `${perimeter}`; } else { maskAnimClass = 'animate-glow'; } }
          return (<div className="absolute top-0 left-0 w-full h-full pointer-events-none select-none" style={{zIndex:surface.zIndex, clipPath:isLineAndMasked?'none':maskClipPath}}>{isLineAndMasked && (<svg className="absolute inset-0 w-full h-full overflow-visible"><polygon points={surface.maskPoints.map(p => `${p.x},${p.y}`).join(' ')} fill="none" stroke={surface.src} strokeWidth={surface.lineWidth||10} className={maskAnimClass} style={maskAnimStyle}/></svg>)}<div className="origin-top-left absolute pointer-events-auto transition-opacity gpu-accelerated" style={{width:`${INTERNAL_WIDTH}px`, height:`${INTERNAL_HEIGHT}px`, transform:transformStyle, opacity:isLineAndMasked?0:surface.opacity}} onClick={(e)=>{if(!isPlaying){e.stopPropagation();onSelect(surface.id);}}}>
          <div style={{width:'100%', height:'100%', transform:`rotate(${rotation}deg)`, transformOrigin:'center', transformStyle:'preserve-3d'}}><div className={`effect-container ${effectClass}`} style={{...shapeStyle}}>{renderContent()}</div>{isSelected&&!isPlaying&&(<div className="absolute inset-0 border-4 border-blue-500/50 pointer-events-none mix-blend-screen" style={{borderRadius:(!surface.maskPoints&&surface.shape==='circle')?'50%':undefined, clipPath:(!surface.maskPoints&&surface.shape==='triangle')?'polygon(50% 0%, 0% 100%, 100% 100%)':undefined}}/>)}</div></div></div>);
        };

        const Sidebar = ({ surfaces, selectedId, editMode, onSetEditMode, onAddSurface, onSelect, onUpdateSurface, onDeleteSurface, onLoadProject, onToggleFullscreen, onCloseMobile, isPlaying, currentTime, onPlay, onStop, onReset, onOpenWindowDrawing, onOpenScreenDrawing, onOpenEffectsModal }) => {
          const [uploadShape, setUploadShape] = useState('rect'); const [keyframeEdit, setKeyframeEdit] = useState({ time: 0, zoom: 1 }); const loadFileInputRef = useRef(null); const scrollContainerRef = useRef(null);
          const selectedSurface = surfaces.find(s => s.id === selectedId);
          const selectedEffectName = useMemo(() => VISUAL_EFFECTS.find(e => e.id === selectedSurface?.effect)?.name || 'Kein Effekt', [selectedSurface]);
          useEffect(() => { if (selectedId && scrollContainerRef.current) setTimeout(() => scrollContainerRef.current?.scrollTo({ top: scrollContainerRef.current.scrollHeight, behavior: 'smooth' }), 100); }, [selectedId]);
          const handleFileUpload = (e) => { const file = e.target.files?.[0]; if (!file) return; e.target.value = ''; const reader = new FileReader(); reader.onload = (event) => { const result = event.target?.result; if (!result) return; if (file.type.startsWith('video/')) { const video = document.createElement('video'); video.preload = 'metadata'; video.onloadedmetadata = () => { const w = video.videoWidth; const h = video.videoHeight; const duration = video.duration || 10; const scale = 400 / Math.max(w, h); let finalW = w * scale; let finalH = h * scale; if (uploadShape === 'circle') { const size = Math.max(finalW, finalH); finalW = size; finalH = size; } onAddSurface(SurfaceType.VIDEO, result, uploadShape, finalW, finalH, duration); }; video.src = result; } else if (file.type.startsWith('image/')) { const img = new Image(); img.onload = () => { const w = img.width; const h = img.height; const scale = 400 / Math.max(w, h); let finalW = w * scale; let finalH = h * scale; if (uploadShape === 'circle') { const size = Math.max(finalW, finalH); finalW = size; finalH = size; } onAddSurface(SurfaceType.IMAGE, result, uploadShape, finalW, finalH); }; img.src = result; } }; reader.readAsDataURL(file); };
          const handleSaveProject = () => { const data = { surfaces }; const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data)); const a = document.createElement('a'); a.setAttribute("href", dataStr); a.setAttribute("download", `lumimap_projekt_${new Date().toISOString().slice(0,10)}.json`); document.body.appendChild(a); a.click(); a.remove(); };
          const handleLoadFileChange = (e) => { const file = e.target.files?.[0]; if (!file) return; const reader = new FileReader(); reader.onload = (ev) => { try { const loaded = JSON.parse(ev.target?.result); onLoadProject(loaded); } catch (err) { alert("Fehler beim Laden."); } }; reader.readAsText(file); e.target.value = ''; };
          const handleAddKeyframe = () => { if (!selectedSurface) return; const newKeyframe = { time: parseFloat(keyframeEdit.time), zoom: parseFloat(keyframeEdit.zoom) }; const otherKeyframes = (selectedSurface.keyframes || []).filter(k => k.time !== newKeyframe.time); const newKeyframes = [...otherKeyframes, newKeyframe].sort((a,b) => a.time - b.time); onUpdateSurface(selectedSurface.id, { keyframes: newKeyframes }); };
          const handleDeleteKeyframe = (time) => { if (!selectedSurface || !selectedSurface.keyframes) return; const newKeyframes = selectedSurface.keyframes.filter(k => k.time !== time); onUpdateSurface(selectedSurface.id, { keyframes: newKeyframes }); };
          const toggleMaskMode = (enabled) => { if (!selectedSurface) return; if (enabled) { onSetEditMode('mask'); if (!selectedSurface.maskPoints || selectedSurface.maskPoints.length === 0) { let newPoints = [...selectedSurface.corners]; if (selectedSurface.shape === 'triangle') { const [p0, p1, p2, p3] = selectedSurface.corners; const top = { x: (p0.x + p1.x)/2, y: (p0.y + p1.y)/2 }; newPoints = [top, p2, p3]; } else if (selectedSurface.shape === 'circle') { newPoints = []; const steps = 16; const [p0, p1, p2, p3] = selectedSurface.corners; for(let i=0; i<steps; i++) { const th = (i/steps)*Math.PI*2 - Math.PI/2; const u = 0.5 + 0.5 * Math.cos(th); const v = 0.5 + 0.5 * Math.sin(th); const x = (1-u)*(1-v)*p0.x + u*(1-v)*p1.x + u*v*p2.x + (1-u)*v*p3.x; const y = (1-u)*(1-v)*p0.y + u*(1-v)*p1.y + u*v*p2.y + (1-u)*v*p3.y; newPoints.push({x,y}); } } onUpdateSurface(selectedSurface.id, { maskPoints: newPoints }); } } else onSetEditMode('perspective'); };
          const resetMask = () => { if (!selectedSurface) return; onUpdateSurface(selectedSurface.id, { maskPoints: [...selectedSurface.corners] }); }; const clearMask = () => { if (!selectedSurface) return; onUpdateSurface(selectedSurface.id, { maskPoints: undefined }); onSetEditMode('perspective'); }; const formatTime = (t) => { const m = Math.floor(t / 60); const s = Math.floor(t % 60); const ms = Math.floor((t % 1) * 10); return `${m}:${s.toString().padStart(2, '0')}.${ms}`; };
          
          return (
            <div className="w-full md:w-80 h-full bg-zinc-900 border-r border-zinc-800 flex flex-col shadow-2xl z-50 overflow-hidden relative mobile-sidebar">
              <div className="p-4 border-b border-zinc-800 flex justify-between items-center bg-zinc-950">
                <h1 className="text-xl font-bold bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">
                  Projection Tool
                </h1>
                <div className="flex gap-4">
                  <button onClick={onCloseMobile} className="text-zinc-400 hover:text-white touch-friendlier" title="Menü">
                    <i className="fa-solid fa-eye-slash"></i>
                  </button>
                  <button onClick={onToggleFullscreen} className="text-zinc-400 hover:text-white touch-friendlier" title="Vollbild">
                    <i className="fa-solid fa-expand"></i>
                  </button>
                  <button onClick={onCloseMobile} className="md:hidden text-zinc-400 hover:text-white touch-friendlier">
                    <i className="fa-solid fa-xmark"></i>
                  </button>
                </div>
              </div>
              
              <div ref={scrollContainerRef} className="flex-1 overflow-y-auto touch-scroll p-4 space-y-4">
                {/* Privacy & License Notices */}
                <PrivacyDisclaimer />
                <LicenseWarning />
                
                <div className="flex gap-2 mb-4">
                  <button onClick={handleSaveProject} className="flex-1 py-2 bg-zinc-800 border border-zinc-700 rounded text-xs text-zinc-300 flex items-center justify-center gap-2 transition hover:bg-zinc-700 touch-target no-select">
                    <i className="fa-solid fa-floppy-disk"></i> Speichern
                  </button>
                  <button onClick={() => loadFileInputRef.current?.click()} className="flex-1 py-2 bg-zinc-800 border border-zinc-700 rounded text-xs text-zinc-300 flex items-center justify-center gap-2 transition hover:bg-zinc-700 touch-target no-select">
                    <i className="fa-solid fa-folder-open"></i> Laden
                  </button>
                  <input type="file" ref={loadFileInputRef} onChange={handleLoadFileChange} accept=".json" className="hidden"/>
                </div>
                
                <hr className="border-zinc-800 mb-4"/>
                
                <div className="flex gap-2 mb-4">
                  <button onClick={onOpenWindowDrawing} className="flex-1 py-3 bg-gradient-to-r from-purple-600 to-blue-600 rounded text-white font-bold flex items-center justify-center shadow-lg hover:brightness-110 transition-all text-xs touch-target no-select">
                    <i className="fa-solid fa-pencil mr-1"></i> Fenster Zeichnen
                  </button>
                  <button onClick={onOpenScreenDrawing} className="flex-1 py-3 bg-gradient-to-r from-green-600 to-teal-600 rounded text-white font-bold flex items-center justify-center shadow-lg hover:brightness-110 transition-all text-xs touch-target no-select">
                    <i className="fa-solid fa-pen-nib mr-1"></i> Direkt Zeichnen
                  </button>
                </div>
                
                <button onClick={() => onAddSurface(SurfaceType.TEXT, '#ffffff', 'rect', 400, 200)} className="w-full py-2 bg-zinc-800 border border-zinc-700 rounded text-xs text-blue-400 font-bold flex items-center justify-center gap-2 mb-4 hover:bg-zinc-700 transition touch-target no-select">
                  <i className="fa-solid fa-font"></i> Text hinzufügen
                </button>
                
                <div className="space-y-2">
                  <label className="text-xs font-semibold text-zinc-500 uppercase">Medien Upload</label>
                  <div className="flex bg-zinc-800 p-1 rounded border border-zinc-700 mb-1">
                    {['rect', 'circle', 'triangle'].map((shape) => (
                      <button key={shape} onClick={()=>setUploadShape(shape)} 
                        className={`flex-1 py-1 rounded text-xs flex justify-center items-center touch-friendlier ${uploadShape===shape?'bg-zinc-600 text-white shadow-sm':'text-zinc-400'}`}>
                        <i className={`fa-regular ${shape==='rect'?'fa-square':shape==='circle'?'fa-circle':'fa-play fa-rotate-270'}`}></i>
                      </button>
                    ))}
                  </div>
                  
                  <MediaUploadDisclaimer className="mb-2" />
                  
                  <label className="flex items-center justify-center p-3 border border-zinc-700 rounded bg-zinc-800 hover:bg-zinc-700 cursor-pointer transition touch-target no-select">
                    <i className="fa-solid fa-upload mr-2 text-zinc-400"></i>
                    <span className="text-xs text-zinc-300 uppercase font-bold">Datei wählen</span>
                    <input type="file" className="hidden" accept="image/*,video/*" onChange={handleFileUpload}/>
                  </label>
                </div>
                
                <div className="space-y-2">
                  <label className="text-xs font-semibold text-zinc-500 uppercase">Neon Linien</label>
                  <div className="grid grid-cols-3 gap-2">
                    <button onClick={() => onAddSurface(SurfaceType.LINE, '#00ffff', 'rect')} className="p-2 border border-zinc-700 rounded bg-zinc-800 flex flex-col items-center hover:bg-zinc-700 transition touch-target no-select">
                      <i className="fa-regular fa-square text-cyan-400 mb-1"></i>
                      <span className="text-[10px]">Rechteck</span>
                    </button>
                    <button onClick={() => onAddSurface(SurfaceType.LINE, '#00ffff', 'circle')} className="p-2 border border-zinc-700 rounded bg-zinc-800 flex flex-col items-center hover:bg-zinc-700 transition touch-target no-select">
                      <i className="fa-regular fa-circle text-cyan-400 mb-1"></i>
                      <span className="text-[10px]">Kreis</span>
                    </button>
                    <button onClick={() => onAddSurface(SurfaceType.LINE, '#00ffff', 'triangle')} className="p-2 border border-zinc-700 rounded bg-zinc-800 flex flex-col items-center hover:bg-zinc-700 transition touch-target no-select">
                      <i className="fa-solid fa-play -rotate-90 text-xs text-cyan-400 mb-1"></i>
                      <span className="text-[10px]">Dreieck</span>
                    </button>
                  </div>
                </div>
                
                <div className="space-y-2">
                  <label className="text-xs font-semibold text-zinc-500 uppercase">Farben</label>
                  <div className="grid grid-cols-3 gap-2">
                    <button onClick={() => onAddSurface(SurfaceType.COLOR, '#ffffff', 'rect')} className="p-2 border border-zinc-700 rounded bg-zinc-800 flex flex-col items-center hover:bg-zinc-700 transition touch-target no-select">
                      <i className="fa-regular fa-square text-zinc-400 mb-1"></i>
                      <span className="text-[10px]">Rechteck</span>
                    </button>
                    <button onClick={() => onAddSurface(SurfaceType.COLOR, '#ffffff', 'circle')} className="p-2 border border-zinc-700 rounded bg-zinc-800 flex flex-col items-center hover:bg-zinc-700 transition touch-target no-select">
                      <i className="fa-regular fa-circle text-zinc-400 mb-1"></i>
                      <span className="text-[10px]">Kreis</span>
                    </button>
                    <button onClick={() => onAddSurface(SurfaceType.COLOR, '#ffffff', 'triangle')} className="p-2 border border-zinc-700 rounded bg-zinc-800 flex flex-col items-center hover:bg-zinc-700 transition touch-target no-select">
                      <i className="fa-solid fa-play -rotate-90 text-xs text-zinc-400 mb-1"></i>
                      <span className="text-[10px]">Dreieck</span>
                    </button>
                  </div>
                </div>
                
                <div className="space-y-2 mt-4 pt-4 border-t border-zinc-800">
                  <h3 className="text-xs font-semibold text-zinc-500 uppercase tracking-wider mb-2">Visuelle Ebenen</h3>
                  {surfaces.map(s => (
                    <div key={s.id} className={`flex items-center p-2 rounded border cursor-pointer group ${selectedId===s.id?'bg-blue-900/30 border-blue-500/50':'bg-zinc-800 border-zinc-700'} touch-target no-select`} 
                      onClick={() => onSelect(s.id)}>
                      <div className="w-8 h-8 rounded bg-zinc-900 mr-3 border border-zinc-700 flex items-center justify-center text-xs text-zinc-500 overflow-hidden">
                        {s.type==='VIDEO'?<i className="fa-solid fa-video"></i>:s.type==='IMAGE'?<img src={s.src} className="w-full h-full object-cover"/>:s.type==='TEXT'?<i className="fa-solid fa-font"></i>:<div className="w-3 h-3 rounded-full" style={{background:s.src}}></div>}
                      </div>
                      <div className="flex-1 min-w-0">
                        <div className="text-sm font-medium text-zinc-200 truncate">{s.name}</div>
                        <div className="text-[10px] text-zinc-500 uppercase">{s.type} {s.maskPoints?'(Maske)':''}</div>
                      </div>
                      <button onClick={(e)=>{e.stopPropagation();onUpdateSurface(s.id,{visible:!s.visible});}} 
                        className={`p-1.5 rounded hover:bg-zinc-700 touch-friendlier ${s.visible?'text-zinc-400':'text-zinc-600'}`}>
                        <i className={`fa-solid ${s.visible?'fa-eye':'fa-eye-slash'}`}></i>
                      </button>
                      <button onClick={(e)=>{e.stopPropagation();onDeleteSurface(s.id);}} 
                        className="p-1.5 rounded hover:bg-red-900/50 text-zinc-600 hover:text-red-400 opacity-0 group-hover:opacity-100 touch-friendlier">
                        <i className="fa-solid fa-trash"></i>
                      </button>
                    </div>
                  ))}
                </div>
                
                {selectedSurface && (
                  <div className="border-t border-zinc-800 pt-4 mt-2">
                    <h3 className="text-xs font-semibold text-zinc-500 uppercase mb-3">
                      Ebene Bearbeiten: <span className="text-white font-bold">{selectedSurface.name}</span>
                    </h3>
                    
                    <div className="bg-zinc-800/50 rounded p-3 mb-4 border border-zinc-700 space-y-3">
                      <div className="flex items-center text-xs text-purple-400 font-bold uppercase">
                        <i className="fa-solid fa-wand-magic-sparkles mr-2"></i> Visueller Effekt
                      </div>
                      <button onClick={onOpenEffectsModal} className="w-full text-left p-2 bg-zinc-900 border border-zinc-700 rounded text-sm text-white flex justify-between items-center hover:border-blue-500 touch-target no-select">
                        <span>{selectedEffectName}</span>
                        <i className="fa-solid fa-chevron-down text-zinc-600"></i>
                      </button>
                    </div>
                    
                    <div className="bg-zinc-800/50 rounded p-2 mb-4 border border-zinc-700">
                      <div className="flex items-center mb-1 text-xs text-blue-400 font-bold uppercase">
                        <i className="fa-solid fa-clock mr-2"></i> Timeline
                      </div>
                      <div className="grid grid-cols-2 gap-2">
                        <div>
                          <label className="text-[10px] text-zinc-400">Start (sek)</label>
                          <input type="number" min="0" step="0.1" value={selectedSurface.timelineStart} 
                            onChange={(e)=>onUpdateSurface(selectedSurface.id,{timelineStart:e.target.value===''?0:parseFloat(e.target.value)})} 
                            className="w-full bg-zinc-900 border border-zinc-700 rounded px-2 py-1 text-xs text-white"/>
                        </div>
                        <div>
                          <label className="text-[10px] text-zinc-400">Dauer (sek)</label>
                          <input type="number" min="0.1" step="0.1" value={selectedSurface.timelineDuration} 
                            onChange={(e)=>onUpdateSurface(selectedSurface.id,{timelineDuration:e.target.value===''?0:parseFloat(e.target.value)})} 
                            className="w-full bg-zinc-900 border border-zinc-700 rounded px-2 py-1 text-xs text-white"/>
                        </div>
                      </div>
                    </div>
                    
                    {selectedSurface.type===SurfaceType.TEXT&&(
                      <div className="bg-zinc-800/50 rounded p-2 mb-4 border border-zinc-700 space-y-3">
                        <div className="flex items-center mb-1 text-xs text-blue-400 font-bold uppercase">
                          <i className="fa-solid fa-keyboard mr-2"></i> Text-Optionen
                        </div>
                        <textarea value={selectedSurface.textContent||''} 
                          onChange={(e)=>onUpdateSurface(selectedSurface.id,{textContent:e.target.value})} 
                          className="w-full bg-zinc-900 border border-zinc-700 rounded p-2 text-xs text-white h-16 outline-none focus:border-blue-500" 
                          placeholder="Dein Text hier..."/>
                        <div className="flex items-center justify-between">
                          <span className="text-[10px] text-zinc-400 uppercase font-bold">Ausrichtung</span>
                          <div className="flex gap-1 bg-zinc-900 p-1 rounded border border-zinc-700">
                            <button onClick={()=>onUpdateSurface(selectedSurface.id,{isVertical:false})} 
                              className={`px-2 py-1 text-[10px] rounded ${!selectedSurface.isVertical?'bg-blue-600 text-white':'text-zinc-500'} touch-target no-select`}>
                              Horizontal
                            </button>
                            <button onClick={()=>onUpdateSurface(selectedSurface.id,{isVertical:true})} 
                              className={`px-2 py-1 text-[10px] rounded ${selectedSurface.isVertical?'bg-blue-600 text-white':'text-zinc-500'} touch-target no-select`}>
                              Vertikal
                            </button>
                          </div>
                        </div>
                        <div className="space-y-1">
                          <div className="flex justify-between text-[10px] text-zinc-400">
                            <label>Schriftgröße</label>
                            <span>{selectedSurface.fontSize||100}px</span>
                          </div>
                          <input type="range" min="10" max="300" step="5" value={selectedSurface.fontSize||100} 
                            onChange={(e)=>onUpdateSurface(selectedSurface.id,{fontSize:parseInt(e.target.value)})} 
                            className="w-full accent-blue-500 h-1 bg-zinc-700 rounded-lg appearance-none cursor-pointer"/>
                        </div>
                      </div>
                    )}
                    
                    {selectedSurface.type===SurfaceType.VIDEO&&(
                      <>
                        <div className="bg-zinc-800/50 rounded p-2 mb-4 border border-zinc-700">
                          <div className="flex items-center mb-1 text-xs text-green-400 font-bold uppercase">
                            <i className="fa-solid fa-volume-high mr-2"></i> Audio & Geschwindigkeit
                          </div>
                          <div className="space-y-3">
                            <div className="space-y-1">
                              <div className="flex justify-between text-[10px] text-zinc-400">
                                <label>Lautstärke</label>
                                <span>{Math.round((selectedSurface.volume??1)*100)}%</span>
                              </div>
                              <input type="range" min="0" max="1" step="0.05" value={selectedSurface.volume??1} 
                                onChange={(e)=>onUpdateSurface(selectedSurface.id,{volume:parseFloat(e.target.value)})} 
                                className="w-full accent-green-500 h-1 bg-zinc-700 rounded-lg appearance-none cursor-pointer"/>
                            </div>
                            <div className="space-y-1">
                              <div className="flex justify-between text-[10px] text-zinc-400">
                                <label>Geschwindigkeit</label>
                                <span>{selectedSurface.playbackRate??1.0}x</span>
                              </div>
                              <input type="range" min="0.1" max="4.0" step="0.1" value={selectedSurface.playbackRate??1.0} 
                                onChange={(e)=>onUpdateSurface(selectedSurface.id,{playbackRate:parseFloat(e.target.value)})} 
                                className="w-full accent-blue-500 h-1 bg-zinc-700 rounded-lg appearance-none cursor-pointer"/>
                            </div>
                            <div className="flex items-center justify-between">
                              <span className="text-[10px] text-zinc-400 uppercase font-bold">Stummschalten</span>
                              <button onClick={()=>onUpdateSurface(selectedSurface.id,{isMuted:!selectedSurface.isMuted})} 
                                className={`w-10 h-5 rounded-full relative transition-colors touch-friendlier ${selectedSurface.isMuted?'bg-red-600':'bg-zinc-700'}`}>
                                <div className={`absolute top-1 w-3 h-3 bg-white rounded-full transition-all ${selectedSurface.isMuted?'left-6':'left-1'}`}></div>
                              </button>
                            </div>
                          </div>
                        </div>
                        
                        <div className="bg-zinc-800/50 rounded p-3 mb-4 border border-zinc-700 space-y-3">
                          <div className="flex items-center text-xs text-purple-400 font-bold uppercase">
                            <i className="fa-solid fa-timeline mr-2"></i> Keyframe Animation (Zoom)
                          </div>
                          <div className="space-y-2 bg-zinc-900/50 p-2 rounded border border-zinc-800">
                            <div className="flex justify-between text-[10px] text-zinc-400">
                              <label>Zeitpunkt: {(keyframeEdit.time*100).toFixed(1)}%</label>
                              <span>({(keyframeEdit.time*(selectedSurface.timelineDuration||10)).toFixed(1)}s)</span>
                            </div>
                            <input type="range" min="0" max="1" step="0.005" value={keyframeEdit.time} 
                              onChange={(e)=>setKeyframeEdit(k=>({...k,time:e.target.value}))} 
                              className="w-full accent-purple-500 h-1.5 bg-zinc-700 rounded-lg appearance-none cursor-pointer"/>
                            <div className="flex justify-between text-[10px] text-zinc-400">
                              <label>Zoom</label>
                              <span>{parseFloat(keyframeEdit.zoom).toFixed(2)}x</span>
                            </div>
                            <input type="range" min="0.1" max="5" step="0.05" value={keyframeEdit.zoom} 
                              onChange={(e)=>setKeyframeEdit(k=>({...k,zoom:e.target.value}))} 
                              className="w-full accent-purple-500 h-1.5 bg-zinc-700 rounded-lg appearance-none cursor-pointer"/>
                            <button onClick={handleAddKeyframe} 
                              className="w-full py-1.5 bg-purple-600 hover:bg-purple-500 rounded text-white text-[10px] font-bold uppercase transition-all shadow-lg touch-target no-select">
                              Keyframe hinzufügen/aktualisieren
                            </button>
                          </div>
                          <div className="space-y-1 max-h-24 overflow-y-auto touch-scroll pr-1">
                            {(selectedSurface.keyframes||[]).map((kf,i)=>(
                              <div key={i} className="flex items-center justify-between bg-zinc-900 p-1.5 rounded text-xs">
                                <div className="font-mono text-zinc-400 text-[10px]">
                                  <span className="text-purple-400">T:</span> {(kf.time*100).toFixed(0)}% 
                                  <span className="text-zinc-600 mx-1">|</span> 
                                  <span className="text-purple-400">Z:</span> {kf.zoom.toFixed(2)}x
                                </div>
                                <button onClick={()=>handleDeleteKeyframe(kf.time)} 
                                  disabled={selectedSurface.keyframes.length<=1} 
                                  className="text-zinc-600 hover:text-red-500 text-[10px] disabled:text-zinc-800 disabled:cursor-not-allowed touch-friendlier">
                                  <i className="fa-solid fa-trash"></i>
                                </button>
                              </div>
                            ))}
                          </div>
                        </div>
                      </>
                    )}
                    
                    <div className="flex bg-zinc-800 p-1 rounded border border-zinc-700 mb-4">
                      <button onClick={()=>toggleMaskMode(false)} 
                        className={`flex-1 py-1.5 text-xs font-medium rounded transition-colors touch-target no-select ${editMode==='perspective'?'bg-blue-600 text-white':'text-zinc-400'}`}>
                        <i className="fa-solid fa-arrows-up-down-left-right mr-1"></i> 4-Punkt
                      </button>
                      <button onClick={()=>toggleMaskMode(true)} 
                        className={`flex-1 py-1.5 text-xs font-medium rounded transition-colors touch-target no-select ${editMode==='mask'?'bg-green-600 text-white':'text-zinc-400'}`}>
                        <i className="fa-solid fa-draw-polygon mr-1"></i> Maske
                      </button>
                    </div>
                    
                    {editMode==='mask'&&(
                      <div className="mb-4 p-2 bg-zinc-800/50 border border-green-900/30 rounded space-y-2">
                        <p className="text-[10px] text-zinc-400">
                          <i className="fa-solid fa-info-circle mr-1"></i> Klicke auf <b>+</b> um Punkte hinzuzufügen.<br/>Doppelklick zum Löschen.
                        </p>
                        <div className="flex gap-2">
                          <button onClick={resetMask} className="flex-1 py-1 bg-zinc-700 rounded text-xs text-white touch-target no-select">Reset Form</button>
                          <button onClick={clearMask} className="flex-1 py-1 bg-red-900/30 border border-red-900/50 rounded text-xs text-red-300 touch-target no-select">Maske löschen</button>
                        </div>
                      </div>
                    )}
                    
                    <div className={`space-y-3 ${editMode==='mask'?'opacity-50 pointer-events-none':''}`}>
                      <div className="space-y-1">
                        <label className="text-xs text-zinc-400">Grundform</label>
                        <select value={selectedSurface.shape} 
                          onChange={(e)=>onUpdateSurface(selectedSurface.id,{shape:e.target.value})} 
                          className="w-full bg-zinc-900 border border-zinc-700 rounded px-2 py-1.5 text-sm text-white outline-none">
                          <option value="rect">Rechteck</option>
                          <option value="circle">Kreis</option>
                          <option value="triangle">Dreieck</option>
                        </select>
                      </div>
                      
                      <div className="space-y-1">
                        <div className="flex justify-between text-xs text-zinc-400">
                          <label>Rotation</label>
                          <span>{selectedSurface.rotation||0}°</span>
                        </div>
                        <input type="range" min="0" max="360" step="1" value={selectedSurface.rotation||0} 
                          onChange={(e)=>onUpdateSurface(selectedSurface.id,{rotation:parseInt(e.target.value)})} 
                          className="w-full accent-blue-500 h-1.5 bg-zinc-700 rounded-lg appearance-none cursor-pointer"/>
                      </div>
                      
                      {(selectedSurface.type===SurfaceType.COLOR||selectedSurface.type===SurfaceType.LINE||selectedSurface.type===SurfaceType.TEXT)&&(
                        <div className="space-y-1">
                          <label className="text-xs text-zinc-400">Farbe</label>
                          <div className="flex gap-2">
                            <input type="color" value={selectedSurface.src} 
                              onChange={(e)=>onUpdateSurface(selectedSurface.id,{src:e.target.value})} 
                              className="w-8 h-8 rounded cursor-pointer border-none bg-transparent touch-friendlier"/>
                            <input type="text" value={selectedSurface.src} 
                              onChange={(e)=>onUpdateSurface(selectedSurface.id,{src:e.target.value})} 
                              className="flex-1 bg-zinc-900 border border-zinc-700 rounded px-2 text-sm text-white"/>
                          </div>
                        </div>
                      )}
                      
                      {(selectedSurface.type===SurfaceType.LINE||selectedSurface.type===SurfaceType.IMAGE||selectedSurface.type===SurfaceType.COLOR||selectedSurface.type===SurfaceType.TEXT)&&(
                        <div className="space-y-1">
                          <div className="flex justify-between text-xs text-zinc-400">
                            <label>Animation</label>
                            <input type="checkbox" checked={!!selectedSurface.animationSpeed} 
                              onChange={(e)=>onUpdateSurface(selectedSurface.id,{animationSpeed:e.target.checked?5:0,animationType:'simple'})}/>
                          </div>
                          {selectedSurface.animationSpeed?(
                            <>
                              <input type="range" min="0.1" max="10" step="0.1" value={selectedSurface.animationSpeed} 
                                onChange={(e)=>onUpdateSurface(selectedSurface.id,{animationSpeed:parseFloat(e.target.value)})} 
                                className="w-full accent-cyan-500 h-1 bg-zinc-700 rounded-lg appearance-none cursor-pointer"/>
                              <div className="grid grid-cols-3 gap-1 mt-1">
                                {[{id:'simple',n:'Standard'},{id:'shake',n:'Shake'},{id:'float',n:'Float'},{id:'blink',n:'Blink'},{id:'sway',n:'Sway'},{id:'scale',n:'Scale'},{id:'glitch',n:'Glitch'}].map(anim=>(
                                  <button key={anim.id} onClick={()=>onUpdateSurface(selectedSurface.id,{animationType:anim.id})} 
                                    className={`text-[8px] py-1 border rounded transition-colors uppercase font-bold touch-friendlier ${selectedSurface.animationType===anim.id?'bg-blue-600 border-blue-500 text-white':'border-zinc-700 text-zinc-500 hover:bg-zinc-800'}`}>
                                    {anim.n}
                                  </button>
                                ))}
                                {(selectedSurface.type===SurfaceType.LINE||selectedSurface.type===SurfaceType.COLOR||selectedSurface.type===SurfaceType.IMAGE)&&(
                                  <>
                                    <button onClick={()=>onUpdateSurface(selectedSurface.id,{animationType:'chase'})} 
                                      className={`text-[8px] py-1 border rounded uppercase font-bold touch-friendlier ${selectedSurface.animationType==='chase'?'bg-blue-600 border-blue-500 text-white':'border-zinc-700 text-zinc-500 hover:bg-zinc-800'}`}>
                                      Lauflicht
                                    </button>
                                    <button onClick={()=>onUpdateSurface(selectedSurface.id,{animationType:'draw'})} 
                                      className={`text-[8px] py-1 border rounded uppercase font-bold touch-friendlier ${selectedSurface.animationType==='draw'?'bg-blue-600 border-blue-500 text-white':'border-zinc-700 text-zinc-500 hover:bg-zinc-800'}`}>
                                      Aufbau
                                    </button>
                                  </>
                                )}
                                {selectedSurface.type===SurfaceType.IMAGE&&(
                                  <button onClick={()=>onUpdateSurface(selectedSurface.id,{animationType:'spin3d'})} 
                                    className={`text-[8px] py-1 border rounded uppercase font-bold touch-friendlier ${selectedSurface.animationType==='spin3d'?'bg-blue-600 border-blue-500 text-white':'border-zinc-700 text-zinc-500 hover:bg-zinc-800'}`}>
                                    3D Spin
                                  </button>
                                )}
                                {selectedSurface.type===SurfaceType.TEXT&&(
                                  <>
                                    <button onClick={()=>onUpdateSurface(selectedSurface.id,{animationType:'pulse'})} 
                                      className={`text-[8px] py-1 border rounded uppercase font-bold touch-friendlier ${selectedSurface.animationType==='pulse'?'bg-blue-600 border-blue-500 text-white':'border-zinc-700 text-zinc-500 hover:bg-zinc-800'}`}>
                                      Pulsieren
                                    </button>
                                    <button onClick={()=>onUpdateSurface(selectedSurface.id,{animationType:'flip'})} 
                                      className={`text-[8px] py-1 border rounded uppercase font-bold touch-friendlier ${selectedSurface.animationType==='flip'?'bg-blue-600 border-blue-500 text-white':'border-zinc-700 text-zinc-500 hover:bg-zinc-800'}`}>
                                      3D Flip
                                    </button>
                                  </>
                                )}
                              </div>
                            </>
                          ):null}
                        </div>
                      )}
                      
                      {selectedSurface.type===SurfaceType.LINE&&(
                        <div className="space-y-1">
                          <div className="flex justify-between text-xs text-zinc-400">
                            <label>Linienbreite</label>
                            <span>{selectedSurface.lineWidth||10}px</span>
                          </div>
                          <input type="range" min="1" max="100" value={selectedSurface.lineWidth||10} 
                            onChange={(e)=>onUpdateSurface(selectedSurface.id,{lineWidth:parseInt(e.target.value)})} 
                            className="w-full accent-cyan-500 h-1.5 bg-zinc-700 rounded-lg appearance-none cursor-pointer"/>
                        </div>
                      )}
                      
                      <div className="space-y-1">
                        <label className="text-xs text-zinc-400">Deckkraft</label>
                        <input type="range" min="0" max="1" step="0.01" value={selectedSurface.opacity} 
                          onChange={(e)=>onUpdateSurface(selectedSurface.id,{opacity:parseFloat(e.target.value)})} 
                          className="w-full accent-blue-500 h-1.5 bg-zinc-700 rounded-lg appearance-none"/>
                      </div>
                    </div>
                  </div>
                )}
                
                {/* Copyright Notice in Sidebar */}
                <div className="mt-6 pt-4 border-t border-zinc-800">
                  <div className="text-[9px] text-zinc-600 text-center">
                    <div>© 2024 Projection Mapping Tool</div>
                    <div className="mt-1">
                      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" 
                         target="_blank" 
                         rel="noopener noreferrer nofollow"
                         className="text-blue-400 hover:underline">
                        CC BY-NC-SA 4.0
                      </a>
                      <span className="mx-2">•</span>
                      Nur nicht-kommerzielle Nutzung
                    </div>
                    <div className="text-[8px] text-zinc-700 mt-1">
                      Keine Gewährleistung | Alle Daten bleiben lokal
                    </div>
                  </div>
                </div>
              </div>
              
              <div className="bg-zinc-950 border-t border-zinc-800 p-4">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-xs text-zinc-500 font-mono">{formatTime(currentTime)}</span>
                  <div className="flex gap-2">
                    {!isPlaying?(
                      <button onClick={onPlay} className="w-8 h-8 rounded-full bg-green-600 hover:bg-green-500 text-white flex items-center justify-center transition-colors touch-friendlier">
                        <i className="fa-solid fa-play"></i>
                      </button>
                    ):(
                      <button onClick={onStop} className="w-8 h-8 rounded-full bg-yellow-600 hover:bg-yellow-500 text-white flex items-center justify-center transition-colors touch-friendlier">
                        <i className="fa-solid fa-pause"></i>
                      </button>
                    )}
                    <button onClick={onReset} className="w-8 h-8 rounded-full bg-zinc-800 hover:bg-zinc-700 text-white flex items-center justify-center transition-colors touch-friendlier">
                      <i className="fa-solid fa-stop"></i>
                    </button>
                  </div>
                </div>
                <div className="h-1 bg-zinc-800 rounded overflow-hidden">
                  <div className="h-full bg-blue-500 w-full animate-pulse opacity-20"></div>
                </div>
              </div>
            </div>
          );
        };

        const App = () => {
          const [surfaces, setSurfaces] = useState([]);
          const [selectedId, setSelectedId] = useState(null); 
          const [isUIHidden, setIsUIHidden] = useState(false); 
          const [editMode, setEditMode] = useState('perspective'); 
          const [isPlaying, setIsPlaying] = useState(false); 
          const [currentTime, setCurrentTime] = useState(0); 
          const [showPlayModal, setShowPlayModal] = useState(false); 
          const [playConfig, setPlayConfig] = useState({ loopDuration: 30, mode: 'infinite', count: 1, stopAfter: 60 }); 
          const [playLoopCount, setPlayLoopCount] = useState(0); 
          const [showWindowDrawing, setShowWindowDrawing] = useState(false); 
          const [showScreenDrawing, setShowScreenDrawing] = useState(false);
          const [showEffectsModal, setShowEffectsModal] = useState(false);
          const [showStartupModal, setShowStartupModal] = useState(true);
          const timerRef = useRef(null);
          const [draggingHandle, setDraggingHandle] = useState(null); 
          const [draggingSurface, setDraggingSurface] = useState(null); 
          const [lastMousePos, setLastMousePos] = useState(null); 
          const containerRef = useRef(null);

          // Auto-show startup modal on first visit
          useEffect(() => {
            const hasSeenModal = localStorage.getItem('projectionToolHasSeenModal');
            if (!hasSeenModal) {
              setShowStartupModal(true);
              localStorage.setItem('projectionToolHasSeenModal', 'true');
            }
          }, []);

          const getMaxDuration = () => { 
              let max = 10; 
              surfaces.forEach(s => { const end = (s.timelineStart || 0) + (s.timelineDuration || 10); if (end > max) max = end; }); 
              return max; 
          };
          const handleOpenPlayModal = () => { setPlayConfig(prev => ({ ...prev, loopDuration: getMaxDuration() })); setShowPlayModal(true); };
          const handleStartPlayback = () => { setShowPlayModal(false); setIsPlaying(true); setPlayLoopCount(0); setCurrentTime(0); setSelectedId(null); };
          const handleStop = () => setIsPlaying(false); 
          const handleReset = () => { setIsPlaying(false); setCurrentTime(0); };
          
          useEffect(() => { 
              if (isPlaying) { 
                  const startTime = Date.now() - (currentTime * 1000); 
                  const startTimestamp = Date.now(); 
                  timerRef.current = window.setInterval(() => { 
                      const now = Date.now(); 
                      const rawTime = (now - startTime) / 1000; 
                      if (playConfig.mode === 'timer' && (now - startTimestamp)/1000 >= playConfig.stopAfter) { 
                          handleStop(); return; 
                      } 
                      if (playConfig.loopDuration > 0 && rawTime >= playConfig.loopDuration) { 
                          if (playConfig.mode === 'count') { 
                              const newLoopCount = playLoopCount + 1; 
                              if (newLoopCount >= playConfig.count) { 
                                  handleStop(); 
                                  return; 
                              } 
                              setPlayLoopCount(newLoopCount); 
                          } 
                      } 
                      const newCurrentTime = playConfig.loopDuration > 0 ? rawTime % playConfig.loopDuration : rawTime; 
                      setCurrentTime(newCurrentTime); 
                  }, 50); 
              } else { 
                  if (timerRef.current) clearInterval(timerRef.current); 
                  timerRef.current = null; 
              } 
              return () => { if (timerRef.current) clearInterval(timerRef.current); }; 
          }, [isPlaying, playConfig, playLoopCount]);

          const getLocalPos = useCallback((clientX, clientY) => { if (!containerRef.current) return { x: clientX, y: clientY }; const rect = containerRef.current.getBoundingClientRect(); return { x: clientX - rect.left, y: clientY - rect.top }; }, []);
          const handleAddSurface = (type, src, shape = 'rect', initialWidth = 300, initialHeight = 300, duration = 0, customCx = null, customCy = null) => { if (!containerRef.current) return; const rect = containerRef.current.getBoundingClientRect(); const cx = customCx !== null ? customCx : (rect.width / 2); const cy = customCy !== null ? customCy : (rect.height / 2); const halfW = initialWidth / 2; const halfH = initialHeight / 2; const newSurface = { id: uuidv4(), name: `${type==='TEXT'?'Text':'Fläche'} ${surfaces.length+1}`, type, shape, src, corners: [{x:cx-halfW, y:cy-halfH}, {x:cx+halfW, y:cy-halfH}, {x:cx+halfW, y:cy+halfH}, {x:cx-halfW, y:cy+halfH}], opacity: 1, visible: true, zIndex: surfaces.length + 1, lineWidth: 10, animationSpeed: 0, animationType: 'simple', isMuted: false, volume: 1, playbackRate: 1.0, timelineStart: 0, timelineDuration: duration > 0 ? duration : 10, rotation: 0, videoDuration: duration, loopMode: 'infinite', loopCount: 1, textContent: type==='TEXT'?'PROJECTION':'', fontSize: type==='TEXT'?80:0, isVertical: false, keyframes: [], effect: 'none' }; setSurfaces(prev => [...prev, newSurface]); setSelectedId(newSurface.id); setEditMode('perspective'); return newSurface; };
          const handleSaveWindowDrawing = (dataUrl) => { setShowWindowDrawing(false); const newSurface = handleAddSurface(SurfaceType.IMAGE, dataUrl, 'rect', 500, 500); if (newSurface) handleUpdateSurface(newSurface.id, { animationSpeed: 4, animationType: 'simple', name: 'Zeichnung' }); };
          const handleSaveScreenDrawing = (dataUrl, rect) => { setShowScreenDrawing(false); if (!containerRef.current) return; const containerRect = containerRef.current.getBoundingClientRect(); const gCx = rect.x + (rect.w / 2); const gCy = rect.y + (rect.h / 2); const lCx = gCx - containerRect.left; const lCy = gCy - containerRect.top; const newSurface = handleAddSurface(SurfaceType.IMAGE, dataUrl, 'rect', rect.w, rect.h, 0, lCx, lCy); if (newSurface) handleUpdateSurface(newSurface.id, { animationSpeed: 5, animationType: 'simple', name: 'Direkt-Zeichnung' }); };
          const handleUpdateSurface = (id, updates) => setSurfaces(prev => prev.map(s => s.id === id ? { ...s, ...updates } : s));
          const handleDeleteSurface = (id) => { setSurfaces(prev => prev.filter(s => s.id !== id)); if (selectedId === id) setSelectedId(null); };
          const handleSelectEffect = (effectId) => { if(selectedId) handleUpdateSurface(selectedId, { effect: effectId }); setShowEffectsModal(false); };
          const handleLoadProject = (loadedData) => {
              const surfacesArray = Array.isArray(loadedData.surfaces) 
                  ? loadedData.surfaces
                  : Array.isArray(loadedData)
                  ? loadedData
                  : null;

              if (!surfacesArray) {
                  alert("Projektdatei ungültig oder leer.");
                  return;
              }

              const migratedSurfaces = surfacesArray.map((s, index) => {
                  const defaultSurface = {
                      id: uuidv4(), name: `Ebene ${index + 1}`, type: SurfaceType.COLOR,
                      shape: 'rect', src: '#ffffff',
                      corners: [{x: 100, y: 100}, {x: 400, y: 100}, {x: 400, y: 400}, {x: 100, y: 400}],
                      opacity: 1, visible: true, zIndex: index, lineWidth: 10,
                      animationSpeed: 0, animationType: 'simple', isMuted: false,
                      volume: 1, playbackRate: 1.0, timelineStart: 0,
                      timelineDuration: 10, rotation: 0, textContent: '',
                      fontSize: 80, isVertical: false, keyframes: [], effect: 'none',
                      maskPoints: undefined,
                      videoDuration: 0, loopMode: 'infinite', loopCount: 1,
                  };

                  const sanitized = { ...defaultSurface, ...s };
                  sanitized.zIndex = index;

                  if (!sanitized.id || typeof sanitized.id !== 'string') {
                      sanitized.id = uuidv4();
                  }

                  if (!Array.isArray(sanitized.corners) || sanitized.corners.length !== 4 || sanitized.corners.some(c => typeof c?.x !== 'number' || typeof c?.y !== 'number')) {
                      sanitized.corners = defaultSurface.corners;
                  }

                  if (!Array.isArray(sanitized.keyframes)) {
                      sanitized.keyframes = [];
                  }

                  sanitized.opacity = Number.isFinite(Number(sanitized.opacity)) ? Math.max(0, Math.min(1, Number(sanitized.opacity))) : 1;
                  sanitized.rotation = Number.isFinite(Number(sanitized.rotation)) ? Number(sanitized.rotation) : 0;
                  sanitized.timelineStart = Number.isFinite(Number(sanitized.timelineStart)) ? Number(sanitized.timelineStart) : 0;
                  sanitized.timelineDuration = Number.isFinite(Number(sanitized.timelineDuration)) && Number(sanitized.timelineDuration) > 0 ? Number(sanitized.timelineDuration) : 10;
                  sanitized.lineWidth = Number.isFinite(Number(sanitized.lineWidth)) ? Number(sanitized.lineWidth) : 10;
                  sanitized.fontSize = Number.isFinite(Number(sanitized.fontSize)) ? Number(sanitized.fontSize) : 80;
                  sanitized.animationSpeed = Number.isFinite(Number(sanitized.animationSpeed)) ? Number(sanitized.animationSpeed) : 0;
                  sanitized.volume = Number.isFinite(Number(sanitized.volume)) ? Number(sanitized.volume) : 1;
                  sanitized.playbackRate = Number.isFinite(Number(sanitized.playbackRate)) ? Number(sanitized.playbackRate) : 1.0;

                  return sanitized;
              });

              setSurfaces(migratedSurfaces);
              setSelectedId(null);
              alert(`${migratedSurfaces.length} Ebenen erfolgreich geladen.`);
          };
          const handleMouseDown = (e) => { if (isPlaying) return; if (e.target === containerRef.current) setSelectedId(null); }; const getEventClientPos = (e) => ('touches' in e ? {x:e.touches[0].clientX, y:e.touches[0].clientY} : {x:e.clientX, y:e.clientY}); const handleHandleStart = (e, surfaceId, index, isMask) => { if(isPlaying)return; e.stopPropagation(); if('touches' in e)e.preventDefault(); setDraggingHandle({surfaceId,index,isMask}); setSelectedId(surfaceId); }; const handleHandleDoubleClick = (e, surfaceId, index, isMask) => { if(isPlaying||!isMask)return; e.stopPropagation(); const s=surfaces.find(s=>s.id===surfaceId); if(!s||!s.maskPoints||s.maskPoints.length<=3)return; const newMask=[...s.maskPoints]; newMask.splice(index,1); handleUpdateSurface(surfaceId,{maskPoints:newMask}); }; const handleGhostStart = (e, surfaceId, insertIndex) => { if(isPlaying)return; e.stopPropagation(); if('touches' in e)e.preventDefault(); const s=surfaces.find(s=>s.id===surfaceId); if(!s||!s.maskPoints)return; const len=s.maskPoints.length; const prevIndex=(insertIndex-1+len)%len; const p1=s.maskPoints[prevIndex]; const p2=s.maskPoints[insertIndex%len]; const midPoint={x:(p1.x+p2.x)/2,y:(p1.y+p2.y)/2}; const newMask=[...s.maskPoints]; newMask.splice(insertIndex,0,midPoint); handleUpdateSurface(surfaceId,{maskPoints:newMask}); setDraggingHandle({surfaceId,index:insertIndex,isMask:true}); setSelectedId(surfaceId); }; const handleSurfaceStart = (e, surfaceId) => { if(isPlaying||draggingHandle)return; e.stopPropagation(); if('touches' in e)e.preventDefault(); const {x,y}=getEventClientPos(e); setSelectedId(surfaceId); setDraggingSurface(surfaceId); setLastMousePos(getLocalPos(x,y)); };
          const processMove = useCallback((clientX, clientY) => { if(isPlaying)return; const mousePos=getLocalPos(clientX,clientY); if(draggingHandle){setSurfaces(prev=>prev.map(s=>{if(s.id!==draggingHandle.surfaceId)return s; if(draggingHandle.isMask){const newMask=[...s.maskPoints]; if(newMask[draggingHandle.index])newMask[draggingHandle.index]=mousePos; return {...s,maskPoints:newMask};} else {const newCorners=[...s.corners]; newCorners[draggingHandle.index]=mousePos; return {...s,corners:newCorners};}}));}else if(draggingSurface&&lastMousePos){const dx=mousePos.x-lastMousePos.x; const dy=mousePos.y-lastMousePos.y; setSurfaces(prev=>prev.map(s=>{if(s.id!==draggingSurface)return s; const newCorners=s.corners.map(p=>({x:p.x+dx,y:p.y+dy})); let newMaskPoints=s.maskPoints; if(s.maskPoints)newMaskPoints=s.maskPoints.map(p=>({x:p.x+dx,y:p.y+dy})); return {...s,corners:newCorners,maskPoints:newMaskPoints};})); setLastMousePos(mousePos);}}, [draggingHandle, draggingSurface, lastMousePos, getLocalPos, isPlaying]);
          useEffect(() => { const handleMouseMove=(e)=>processMove(e.clientX,e.clientY); const handleTouchMove=(e)=>{if(draggingHandle||draggingSurface)e.preventDefault();processMove(e.touches[0].clientX,e.touches[0].clientY);}; const handleEnd=()=>{setDraggingHandle(null);setDraggingSurface(null);setLastMousePos(null);}; window.addEventListener('mousemove',handleMouseMove); window.addEventListener('mouseup',handleEnd); window.addEventListener('touchmove',handleTouchMove,{passive:false}); window.addEventListener('touchend',handleEnd); return ()=>{window.removeEventListener('mousemove',handleMouseMove);window.removeEventListener('mouseup',handleEnd);window.removeEventListener('touchmove',handleTouchMove);window.removeEventListener('touchend',handleEnd);}; }, [processMove, draggingHandle, draggingSurface]);
          useEffect(() => { const handleKeyDown=(e)=>{if(['INPUT','TEXTAREA','SELECT'].includes(e.target.tagName))return; if(e.key==='Escape')setSelectedId(null); if(e.key==='Delete'||e.key==='Backspace'){if(selectedId&&!isPlaying)handleDeleteSurface(selectedId);}if(e.key==='h')setIsUIHidden(prev=>!prev);if(e.key==='i'&&e.ctrlKey)setShowStartupModal(true);}; window.addEventListener('keydown',handleKeyDown); return ()=>window.removeEventListener('keydown',handleKeyDown); }, [selectedId, isPlaying]);
          const toggleFullscreen=()=>{if(!document.fullscreenElement)document.documentElement.requestFullscreen();else document.exitFullscreen();}; const selectedSurface=surfaces.find(s=>s.id===selectedId);

          return (
            <div className="flex w-full overflow-hidden relative font-sans text-gray-200" style={{height:'100dvh'}}>
              {/* Modals */}
              {showStartupModal && <StartupInfoModal onClose={() => setShowStartupModal(false)} />}
              
              {showPlayModal && (
                <div className="absolute inset-0 bg-black/80 z-[300] flex items-center justify-center p-4">
                  <div className="w-full max-w-sm bg-zinc-900 border border-zinc-700 rounded-lg p-5 shadow-2xl">
                    <h3 className="text-lg font-bold text-white mb-4 border-b border-zinc-800 pb-2">Sequenz-Einstellung</h3>
                    <div className="space-y-4 mb-6">
                      <div>
                        <label className="text-xs text-zinc-400 block mb-1 uppercase font-bold">Länge (Sekunden)</label>
                        <input type="number" min="1" step="0.1" value={playConfig.loopDuration} 
                          onChange={(e)=>setPlayConfig(prev=>({...prev,loopDuration:parseFloat(e.target.value)}))} 
                          className="w-full bg-black border border-zinc-700 rounded px-3 py-2 text-white outline-none focus:border-blue-500"/>
                      </div>
                      <div>
                        <label className="text-xs text-zinc-400 block mb-1 uppercase font-bold">Modus</label>
                        <div className="flex flex-col gap-2">
                          <label className="flex items-center gap-2 p-2 rounded bg-zinc-800 border border-zinc-700 cursor-pointer transition-colors hover:bg-zinc-700">
                            <input type="radio" name="playMode" checked={playConfig.mode==='infinite'} 
                              onChange={()=>setPlayConfig(prev=>({...prev,mode:'infinite'}))} className="accent-green-500"/>
                            <span className="text-sm">Unendlich</span>
                          </label>
                          <div className={`p-2 rounded border border-zinc-700 transition-colors ${playConfig.mode==='count'?'bg-zinc-800 border-green-900':'bg-zinc-900'}`}>
                            <label className="flex items-center gap-2 cursor-pointer mb-2">
                              <input type="radio" name="playMode" checked={playConfig.mode==='count'} 
                                onChange={()=>setPlayConfig(prev=>({...prev,mode:'count'}))} className="accent-green-500"/>
                              <span className="text-sm">Anzahl Durchläufe:</span>
                            </label>
                            {playConfig.mode==='count'&&
                              <input type="number" min="1" value={playConfig.count} 
                                onChange={(e)=>setPlayConfig(prev=>({...prev,count:parseInt(e.target.value)}))} 
                                className="w-full bg-black border border-zinc-700 rounded px-2 py-1 text-sm text-white focus:border-green-500 outline-none"/>
                            }
                          </div>
                          <div className={`p-2 rounded border border-zinc-700 transition-colors ${playConfig.mode==='timer'?'bg-zinc-800 border-green-900':'bg-zinc-900'}`}>
                            <label className="flex items-center gap-2 cursor-pointer mb-2">
                              <input type="radio" name="playMode" checked={playConfig.mode==='timer'} 
                                onChange={()=>setPlayConfig(prev=>({...prev,mode:'timer'}))} className="accent-green-500"/>
                              <span className="text-sm">Stop nach Zeit (Sek):</span>
                            </label>
                            {playConfig.mode==='timer'&&
                              <input type="number" min="1" value={playConfig.stopAfter} 
                                onChange={(e)=>setPlayConfig(prev=>({...prev,stopAfter:parseInt(e.target.value)}))} 
                                className="w-full bg-black border border-zinc-700 rounded px-2 py-1 text-sm text-white focus:border-green-500 outline-none"/>
                            }
                          </div>
                        </div>
                      </div>
                    </div>
                    <div className="flex gap-3">
                      <button onClick={()=>setShowPlayModal(false)} className="flex-1 py-2 bg-zinc-800 rounded text-zinc-300 font-bold touch-target no-select">
                        Abbruch
                      </button>
                      <button onClick={handleStartPlayback} className="flex-1 py-2 bg-green-600 rounded text-white font-bold shadow-lg shadow-green-900/20 touch-target no-select">
                        Wiedergeben
                      </button>
                    </div>
                  </div>
                </div>
              )}
              
              {showWindowDrawing && <DrawingModal onClose={() => setShowWindowDrawing(false)} onSave={handleSaveWindowDrawing} />}
              {showScreenDrawing && <ScreenDrawingOverlay onClose={() => setShowScreenDrawing(false)} onSave={handleSaveScreenDrawing} />}
              {showEffectsModal && <EffectsLibraryModal onClose={()=>setShowEffectsModal(false)} onSelect={handleSelectEffect} />}
              
              {/* Sidebar */}
              <div className={`absolute left-0 top-0 h-full max-w-full transition-transform duration-300 z-[100] ${isUIHidden?'-translate-x-full':'translate-x-0'} tablet-sidebar`}>
                <Sidebar 
                  surfaces={surfaces} 
                  selectedId={selectedId} 
                  editMode={editMode} 
                  onSetEditMode={setEditMode} 
                  onAddSurface={handleAddSurface} 
                  onSelect={setSelectedId} 
                  onUpdateSurface={handleUpdateSurface} 
                  onDeleteSurface={handleDeleteSurface} 
                  onLoadProject={handleLoadProject} 
                  onToggleFullscreen={toggleFullscreen} 
                  onCloseMobile={()=>setIsUIHidden(true)} 
                  isPlaying={isPlaying} 
                  currentTime={currentTime} 
                  onPlay={handleOpenPlayModal} 
                  onStop={handleStop} 
                  onReset={handleReset} 
                  onOpenWindowDrawing={()=>setShowWindowDrawing(true)} 
                  onOpenScreenDrawing={()=>setShowScreenDrawing(true)} 
                  onOpenEffectsModal={()=>setShowEffectsModal(true)} 
                />
              </div>
              
              {/* UI Toggle Button */}
              <div className={`absolute top-4 left-4 z-[90] transition-opacity duration-300 ${isUIHidden?'opacity-100':'opacity-0 pointer-events-none'}`}>
                <button onClick={()=>setIsUIHidden(false)} className="w-10 h-10 bg-zinc-800 rounded-full flex items-center justify-center text-white shadow-lg border border-zinc-700 hover:bg-zinc-700 transition touch-friendlier">
                  <i className="fa-solid fa-bars"></i>
                </button>
              </div>
              
              {/* Main Canvas Area */}
              <div ref={containerRef} className="flex-1 relative bg-black cursor-crosshair overflow-hidden w-full h-full touch-none mobile-canvas" onMouseDown={handleMouseDown}>
                {surfaces.map(surface=>
                  <SurfaceLayer 
                    key={surface.id} 
                    surface={surface} 
                    isSelected={selectedId===surface.id&&!isUIHidden} 
                    onSelect={(id)=>{if(!isUIHidden&&!isPlaying)setSelectedId(id);}} 
                    isPlaying={isPlaying} 
                    globalTime={currentTime}
                  />
                )}
                
                {/* Editing Controls */}
                {selectedSurface&&!isUIHidden&&!isPlaying&&(
                  <div className="absolute inset-0 pointer-events-none z-[200]">
                    {editMode==='perspective'&&(
                      <>
                        <svg className="absolute inset-0 w-full h-full overflow-visible pointer-events-none">
                          <path d={`M ${selectedSurface.corners[0].x} ${selectedSurface.corners[0].y} L ${selectedSurface.corners[1].x} ${selectedSurface.corners[1].y} L ${selectedSurface.corners[2].x} ${selectedSurface.corners[2].y} L ${selectedSurface.corners[3].x} ${selectedSurface.corners[3].y} Z`} 
                            fill="none" stroke="#3b82f6" strokeWidth="1" strokeDasharray="4 2"/>
                        </svg>
                        {selectedSurface.corners.map((corner,idx)=>
                          <div key={`c-${idx}`} className="absolute w-8 h-8 bg-blue-500/50 border-2 border-white rounded-full shadow cursor-move pointer-events-auto flex items-center justify-center backdrop-blur-sm transition-transform hover:scale-110 touch-friendlier" 
                            style={{left:corner.x-16,top:corner.y-16}} 
                            onMouseDown={(e)=>handleHandleStart(e,selectedSurface.id,idx,false)} 
                            onTouchStart={(e)=>handleHandleStart(e,selectedSurface.id,idx,false)}>
                            <div className="w-2 h-2 bg-white rounded-full"/>
                          </div>
                        )}
                        <div className="absolute w-10 h-10 bg-white/20 border border-white/50 rounded-full cursor-grab pointer-events-auto flex items-center justify-center backdrop-blur-sm touch-friendlier" 
                          style={{left:(selectedSurface.corners[0].x+selectedSurface.corners[2].x)/2-20,top:(selectedSurface.corners[0].y+selectedSurface.corners[2].y)/2-20}} 
                          onMouseDown={(e)=>handleSurfaceStart(e,selectedSurface.id)} 
                          onTouchStart={(e)=>handleSurfaceStart(e,selectedSurface.id)}>
                          <i className="fa-solid fa-arrows-up-down-left-right text-sm text-white"></i>
                        </div>
                      </>
                    )}
                    {editMode==='mask'&&selectedSurface.maskPoints&&(
                      <>
                        <svg className="absolute inset-0 w-full h-full overflow-visible pointer-events-none">
                          <polygon points={selectedSurface.maskPoints.map(p=>`${p.x},${p.y}`).join(' ')} fill="none" stroke="#22c55e" strokeWidth="2"/>
                        </svg>
                        {selectedSurface.maskPoints.map((point,idx)=>{
                          const nextIdx=(idx+1)%selectedSurface.maskPoints.length; 
                          const nextPoint=selectedSurface.maskPoints[nextIdx]; 
                          const midX=(point.x+nextPoint.x)/2; 
                          const midY=(point.y+nextPoint.y)/2; 
                          return (
                            <React.Fragment key={`m-${idx}`}>
                              <div className="absolute w-6 h-6 bg-green-500 border-2 border-white rounded-sm shadow cursor-move pointer-events-auto flex items-center justify-center z-10 hover:scale-110 transition-transform touch-friendlier" 
                                style={{left:point.x-12,top:point.y-12}} 
                                onMouseDown={(e)=>handleHandleStart(e,selectedSurface.id,idx,true)} 
                                onTouchStart={(e)=>handleHandleStart(e,selectedSurface.id,idx,true)} 
                                onDoubleClick={(e)=>handleHandleDoubleClick(e,selectedSurface.id,idx,true)}/>
                              <div className="absolute w-5 h-5 bg-green-500/30 border border-green-300 rounded-full cursor-pointer pointer-events-auto flex items-center justify-center z-0 transition-all hover:bg-green-500 hover:scale-110 touch-friendlier" 
                                style={{left:midX-10,top:midY-10}} 
                                onMouseDown={(e)=>handleGhostStart(e,selectedSurface.id,nextIdx)} 
                                onTouchStart={(e)=>handleGhostStart(e,selectedSurface.id,nextIdx)}>
                                <i className="fa-solid fa-plus text-[10px] text-white"></i>
                              </div>
                            </React.Fragment>
                          );
                        })}
                      </>
                    )}
                  </div>
                )}
              </div>
              
              {/* Info Button (optional) */}
              <button 
                onClick={() => setShowStartupModal(true)}
                className="fixed bottom-4 left-4 z-[90] w-10 h-10 bg-blue-600 rounded-full flex items-center justify-center text-white shadow-lg hover:bg-blue-500 transition-colors touch-friendlier"
                title="Info & Lizenz"
              >
                <i className="fa-solid fa-info"></i>
              </button>
            </div>
          );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
